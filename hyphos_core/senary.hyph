// Hyphos Core - Senary Mathematics Metaword
// Pure base-6 mathematical operations as core language feature

/**
 * HYPHOS CORE - SENARY NUMBER SYSTEM METAWORD
 * ============================================
 * 
 * Core implementation of the senary (base-6) number system that forms the
 * mathematical foundation of the Seigr ecosystem. This metaword provides
 * fundamental arithmetic operations, conversions, and validations for
 * senary number manipulation with high precision and efficiency.
 * 
 * MATHEMATICAL FOUNDATION:
 * Senary (base-6) uses digits {0, 1, 2, 3, 4, 5} where each position
 * represents a power of 6:
 * - Position 0: 6⁰ = 1
 * - Position 1: 6¹ = 6  
 * - Position 2: 6² = 36
 * - Position n: 6ⁿ
 * 
 * ADVANTAGES OF SENARY:
 * - Natural alignment with biological systems (6 fingers historically)
 * - Optimal trade-off between digit count and computational efficiency
 * - Enhanced cryptographic properties through non-standard base
 * - Reduced computational complexity in certain algorithms
 * - Natural compatibility with quantum computing (6-state systems)
 * 
 * PRECISION AND ACCURACY:
 * - Supports arbitrary precision arithmetic
 * - Handles both integer and fractional senary numbers
 * - Maintains exact representations without floating-point errors
 * - Optimized algorithms for carry/borrow operations
 * 
 * INTEGRATION WITH SEIGR:
 * - Primary number system for all cryptographic operations
 * - Used in quantum seigbit computations
 * - Foundation for sidereal time calculations
 * - Core of energy management computations
 * 
 * @author Sergi Saldaña-Massó (sergism77)
 * @version 1.0.0
 * @since Hyphos Core v1.0
 * @mathematical_base 6 (senary)
 * @precision Arbitrary precision integer and fractional arithmetic
 */

metaword senary {
    /**
     * SENARY NUMBER CONSTRUCTOR
     * =========================
     * 
     * Creates a senary number from various input types with automatic type
     * detection and conversion. This is the primary factory function for
     * creating senary number objects throughout the Seigr ecosystem.
     * 
     * INPUT TYPE HANDLING:
     * - String input: Validates senary digits (0-5) and creates representation
     * - Integer input: Converts decimal to senary using base conversion
     * - Other types: Attempts pure senary representation via type coercion
     * 
     * VALIDATION PROCESS:
     * - String inputs validated for valid senary digits only
     * - Decimal conversion uses efficient modulo-6 algorithm
     * - Error handling for invalid inputs with descriptive messages
     * 
     * INTERNAL REPRESENTATION:
     * - Stores digits as array for efficient arithmetic operations
     * - Maintains sign information for negative numbers
     * - Includes precision metadata for fractional parts
     * 
     * @param input_value Input to convert to senary (string, integer, or other)
     * @return $SenaryNumber Validated senary number object with:
     *   - digits: Array of senary digits [0-5]
     *   - sign: Boolean indicating positive (false) or negative (true)
     *   - precision: Number of fractional digits
     *   - value: String representation for display
     * 
     * @throws ValidationError If string contains invalid senary digits
     * @throws ConversionError If input type cannot be converted
     * 
     * @example
     * let senary_string = senary.create("12345")     // From senary string
     * let senary_decimal = senary.create(156)        // From decimal (156₁₀ = 424₆)
     * let senary_computed = senary.create(result)    // From computation result
     * 
     * @performance O(log₆(n)) for decimal conversion, O(n) for string validation
     */
    fun create(input_value) -> $SenaryNumber {
        // Create a senary number from input
        if type.of(input_value) == "string" {
            return validate_senary_digits(input_value)
        } else if type.of(input_value) == "integer" {
            return decimal_to_senary(input_value)
        }
        
        return pure_senary_representation(input_value)
    }
    
    /**
     * SENARY ADDITION OPERATION
     * =========================
     * 
     * Performs pure senary addition using digit-by-digit arithmetic with
     * proper carry handling. This implements the fundamental addition
     * algorithm optimized for base-6 mathematics.
     * 
     * ALGORITHM DETAILS:
     * 1. Process digits from least significant (rightmost) position
     * 2. Add corresponding digits plus any carry from previous position
     * 3. If sum ≥ 6, generate carry and reduce sum modulo 6
     * 4. Continue until all digits processed and no carry remains
     * 
     * CARRY LOGIC:
     * - Carry occurs when digit sum reaches or exceeds 6
     * - New carry = floor(sum / 6)
     * - Result digit = sum mod 6
     * - Process continues until carry = 0
     * 
     * PRECISION HANDLING:
     * - Automatically handles numbers of different lengths
     * - Zero-pads shorter numbers for consistent processing
     * - Maintains precision through fractional parts
     * 
     * @param a First senary number addend
     * @param b Second senary number addend  
     * @return $SenaryNumber Sum a + b in senary representation
     * 
     * @complexity O(max(|a|, |b|)) where |n| is number of digits
     * @accuracy Exact arithmetic with no precision loss
     * 
     * @example
     * let a = senary.create("1234")    // 1234₆
     * let b = senary.create("5432")    // 5432₆  
     * let sum = senary.add(a, b)       // Result: 11122₆ (1234₆ + 5432₆)
     * 
     * @mathematical_proof Addition is associative and commutative in senary
     */
    fun add(a, b) -> $SenaryNumber {
        // Pure senary addition - digit by digit with carry
        let carry = 0
        let result_digits = []
        
        // Digit-by-digit senary addition
        let max_length = math.max(a.length, b.length)
        let i = 0
        
        while i < max_length or carry > 0 {
            let digit_a = if i < a.length then a.digits[i] else 0
            let digit_b = if i < b.length then b.digits[i] else 0
            
            let sum = digit_a + digit_b + carry
            result_digits[i] = sum % 6
            carry = sum / 6
            i = i + 1
        }
        
        return senary.from_digits(result_digits)
    }
    
    /**
     * SENARY MULTIPLICATION OPERATION
     * ===============================
     * 
     * Implements senary multiplication using the traditional long multiplication
     * algorithm adapted for base-6 arithmetic. Uses partial products and
     * positional shifting to compute the final result efficiently.
     * 
     * ALGORITHM STRATEGY:
     * 1. For each digit in multiplicand (b), create partial product
     * 2. Multiply entire multiplicand (a) by single digit
     * 3. Shift partial product by appropriate number of positions  
     * 4. Sum all partial products to get final result
     * 
     * PARTIAL PRODUCT METHOD:
     * - multiply_by_digit(a, digit): Single-digit multiplication
     * - left_shift(product, positions): Positional value adjustment
     * - Sequential addition: Accumulates all partial products
     * 
     * MATHEMATICAL FOUNDATION:
     * For a × b where b = Σ(bᵢ × 6ⁱ), result = Σ(a × bᵢ × 6ⁱ)
     * This distributes multiplication over positional representation
     * 
     * @param a First senary number (multiplicand)
     * @param b Second senary number (multiplier)
     * @return $SenaryNumber Product a × b in senary representation
     * 
     * @complexity O(|a| × |b|) where |n| is number of digits
     * @accuracy Exact arithmetic with arbitrary precision
     * 
     * @example
     * let a = senary.create("123")     // 123₆ = 51₁₀
     * let b = senary.create("45")      // 45₆ = 29₁₀  
     * let product = senary.multiply(a, b)  // Result: 9051₆ (51×29=1479₁₀)
     * 
     * @optimization Uses partial products to minimize computation
     */
    fun multiply(a, b) -> $SenaryNumber {
        // Senary multiplication using pure base-6 arithmetic
        let result = senary.create("0")
        
        let i = 0
        while i < b.length {
            if b.digits[i] > 0 {
                let partial = senary.multiply_by_digit(a, b.digits[i])
                let shifted = senary.left_shift(partial, i)
                result = senary.add(result, shifted)
            }
            i = i + 1
        }
        
        return result
    }
    
    /**
     * SENARY SUBTRACTION OPERATION
     * ============================
     * 
     * Performs senary subtraction using digit-by-digit arithmetic with
     * proper borrow handling. Implements the standard subtraction algorithm
     * adapted for base-6 mathematics with comprehensive borrow logic.
     * 
     * ALGORITHM PROCESS:
     * 1. Start from least significant digit (rightmost)
     * 2. If minuend digit < subtrahend digit + borrow, need to borrow
     * 3. Add 6 to current minuend digit and set borrow for next position
     * 4. Subtract (subtrahend digit + borrow) from adjusted minuend digit
     * 5. Continue until all digits processed
     * 
     * BORROW MECHANISM:
     * - Borrow occurs when current digit insufficient for subtraction
     * - Borrowing adds 6 to current position (base value)
     * - Sets borrow=1 for next higher position
     * - Ensures non-negative intermediate results
     * 
     * EDGE CASES:
     * - Handles negative results (b > a) with proper sign indication
     * - Manages leading zeros in result representation
     * - Processes numbers of different lengths automatically
     * 
     * @param a Minuend (number being subtracted from)
     * @param b Subtrahend (number being subtracted)
     * @return $SenaryNumber Difference a - b in senary representation
     * 
     * @complexity O(max(|a|, |b|)) linear in digit count
     * @handles_negatives Returns negative flag when b > a
     * 
     * @example
     * let a = senary.create("1000")    // 1000₆ = 216₁₀
     * let b = senary.create("234")     // 234₆ = 112₁₀
     * let diff = senary.subtract(a, b) // Result: 322₆ (216-112=104₁₀)
     * 
     * @mathematical_property Subtraction is not commutative: a-b ≠ b-a
     */
    fun subtract(a, b) -> $SenaryNumber {
        // Pure senary subtraction with borrow
        let borrow = 0
        let result_digits = []
        let max_length = math.max(a.length, b.length)
        
        let i = 0
        while i < max_length {
            let digit_a = if i < a.length then a.digits[i] else 0
            let digit_b = if i < b.length then b.digits[i] else 0
            
            let diff = digit_a - digit_b - borrow
            if diff < 0 {
                diff = diff + 6
                borrow = 1
            } else {
                borrow = 0
            }
            
            result_digits[i] = diff
            i = i + 1
        }
        
        return senary.from_digits(result_digits)
    }
    
    /**
     * SENARY DIVISION OPERATION
     * =========================
     * 
     * Performs integer division in senary using the repeated subtraction
     * algorithm. This method provides exact quotient computation for
     * senary arithmetic without floating-point approximations.
     * 
     * ALGORITHM APPROACH:
     * 1. Validate divisor is not zero (throws error if zero)
     * 2. Initialize quotient to 0 and remainder to dividend
     * 3. Repeatedly subtract divisor from remainder
     * 4. Increment quotient for each successful subtraction
     * 5. Stop when remainder < divisor
     * 
     * MATHEMATICAL FOUNDATION:
     * For a ÷ b, finds q such that a = b×q + r where 0 ≤ r < b
     * - q is the quotient (returned value)
     * - r is the remainder (discarded in integer division)
     * 
     * PERFORMANCE CHARACTERISTICS:
     * - Time complexity: O(a/b) where a,b are numeric values
     * - Inefficient for large quotients but mathematically exact
     * - Suitable for moderate-sized senary computations
     * 
     * @param a Dividend (number being divided)
     * @param b Divisor (number dividing by)
     * @return $SenaryNumber Quotient a ÷ b (integer result)
     * 
     * @throws ArithmeticError If divisor b equals zero
     * @complexity O(value(a)/value(b)) repeated subtraction algorithm
     * @accuracy Exact integer division with no rounding errors
     * 
     * @example
     * let dividend = senary.create("1000")  // 1000₆ = 216₁₀
     * let divisor = senary.create("12")     // 12₆ = 8₁₀
     * let quotient = senary.divide(dividend, divisor)  // Result: 33₆ (27₁₀)
     * 
     * @note For fractional division, use dedicated fractional arithmetic functions
     */
    fun divide(a, b) -> $SenaryNumber {
        // Senary division using repeated subtraction
        if senary.is_zero(b) {
            error("Division by zero in senary arithmetic")
        }
        
        let quotient = senary.create("0")
        let remainder = senary.copy(a)
        
        while senary.greater_or_equal(remainder, b) {
            remainder = senary.subtract(remainder, b)
            quotient = senary.add(quotient, senary.create("1"))
        }
        
        return quotient
    }
    
    /**
     * DECIMAL TO SENARY CONVERSION
     * ============================
     * 
     * Converts a decimal (base-10) integer to senary (base-6) representation
     * using efficient modulo arithmetic. This is a convenience wrapper for
     * the primary decimal_to_senary conversion function.
     * 
     * CONVERSION PROCESS:
     * - Uses repeated division by 6 to extract senary digits
     * - Remainder of each division becomes the next senary digit
     * - Process continues until quotient reaches zero
     * 
     * @param decimal_value Decimal integer to convert
     * @return $SenaryNumber Equivalent senary representation
     * 
     * @complexity O(log₆(n)) where n is the decimal value
     * @wrapper Convenience function for decimal_to_senary()
     * 
     * @example
     * let decimal = 156                    // Decimal input
     * let senary_num = senary.from_int(decimal)  // Result: 424₆
     */
    fun from_int(decimal_value) -> $SenaryNumber {
        return decimal_to_senary(decimal_value)
    }
    
    fun to_decimal(senary_number) -> $Integer {
        return senary_to_decimal(senary_number)
    }
    
    fun validate_digits(input) -> $Boolean {
        let valid_digits = "012345."
        
        for char in input {
            if !string.contains(valid_digits, char) {
                return false
            }
        }
        return true
    }
    
    fun is_zero(senary_number) -> $Boolean {
        for digit in senary_number.digits {
            if digit != 0 {
                return false
            }
        }
        return true
    }
}

fun decimal_to_senary(decimal) -> $SenaryNumber {
    if decimal == 0 {
        return senary.create("0")
    }
    
    let result = ""
    let negative = decimal < 0
    decimal = math.abs(decimal)
    
    while decimal > 0 {
        result = string.from(decimal % 6) + result
        decimal = decimal / 6
    }
    
    if negative {
        result = "-" + result
    }
    
    return senary.create(result)
}

fun senary_to_decimal(senary_number) -> $Integer {
    let digits = senary_number.digits
    let negative = false
    
    if string.starts_with(digits, "-") {
        negative = true
        digits = string.substring(digits, 1)
    }
    
    let result = 0
    for digit in digits {
        result = result * 6 + int.from(digit)
    }
    
    return negative ? -result : result
}
