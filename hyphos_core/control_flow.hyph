/**
 * HYPHOS CORE - CONTROL FLOW METAWORD
 * ====================================
 * 
 * Fundamental control flow constructs with scope management and safety mechanisms.
 * 
 * MAIN FUNCTIONS:
 * - if_statement(condition, then_block, else_block) -> execution_result
 * - while_loop(condition, body_block, max_iterations) -> loop_result
 * - for_loop(initialization, condition, increment, body) -> iteration_result
 * - switch_statement(value, case_map, default_block) -> switch_result
 * - break_execution(loop_context) -> bool
 * - continue_execution(loop_context) -> bool
 * 
 * STRUCTURES:
 * - ExecutionContext: {scope_id, variables, iteration_count, safety_limits}
 * - LoopResult: {iterations_completed, final_state, execution_time, exit_reason}
 * - ConditionalResult: {branch_taken, execution_result, condition_value}
 * 
 * SAFETY MECHANISMS:
 * - MAX_ITERATIONS: Prevents infinite loops (default: 1,000,000)
 * - TIMEOUT_PROTECTION: Maximum execution time limits
 * - MEMORY_MONITORING: Prevents excessive memory allocation
 * - SCOPE_ISOLATION: Automatic variable cleanup
 * 
 * CONTROL STRUCTURES:
 * - IF/ELSE: Conditional execution
 * - WHILE: Condition-based loops
 * - FOR: Counter-based iteration
 * - SWITCH: Multi-branch selection
 * - BREAK/CONTINUE: Loop control
 * 
 * USAGE EXAMPLE:
 * result = control_flow.if_statement(x > 5, then_action, else_action)
 * loop_result = control_flow.while_loop(condition, loop_body, 1000)
 * iteration = control_flow.for_loop(i=0, i<10, i++, action)
 * 
 * @safety Iteration limits and resource monitoring
 * @scope Automatic scope management and cleanup
 */
 * - Consciousness-aware execution for intelligent control decisions
 * - Energy-aware processing to optimize power consumption
 * - Network-distributed execution capabilities for cluster computing
 * 
 * @author Sergi Saldaña-Massó (sergism77)
 * @version 1.0.0
 * @since Hyphos Core v1.0
 * @scope_management Automatic scope creation and cleanup
 * @safety Iteration limits and resource monitoring
 */

metaword control {
    /**
     * CONDITIONAL EXECUTION CONTROL
     * =============================
     * 
     * Implements conditional execution with automatic scope management and
     * complete execution tracking. This function provides the fundamental
     * if-then-else logic with Hyphos-specific enhancements for safety and
     * integration with the broader ecosystem.
     * 
     * SCOPE MANAGEMENT:
     * - Creates isolated scopes for condition evaluation and block execution
     * - Ensures proper variable lifecycle and memory management
     * - Prevents variable leakage between conditional branches
     * - Automatically cleans up resources on block completion
     * 
     * EXECUTION SEMANTICS:
     * - Evaluates condition in current scope context
     * - Executes appropriate block based on condition truthiness
     * - Returns result from executed block or null if no execution
     * - Maintains execution context for debugging and monitoring
     * 
     * SAFETY FEATURES:
     * - Graceful handling of null else_block conditions
     * - Exception propagation with proper scope cleanup
     * - Resource monitoring during block execution
     * - Timeout protection for long-running conditional blocks
     * 
     * @param condition Boolean expression or evaluatable condition
     * @param then_block Code block to execute when condition is true
     * @param else_block Optional code block for false condition
     * @return $Any Result from executed block or null if no execution
     * 
     * @scope_isolation Creates separate scopes for then/else blocks
     * @memory_safe Automatic cleanup prevents resource leaks
     * @exception_safe Proper cleanup on abnormal termination
     * 
     * @example
     * invoke control:
     *     let user_authenticated = security.verify_credentials(token)
     *     let result = if(user_authenticated, {
     *         // Secure operations block
     *         return user.get_protected_data()
     *     }, {
     *         // Unauthorized access block
     *         security.log_unauthorized_attempt()
     *         return error.unauthorized()
     *     })
     * transcend
     */
    fun if(condition, then_block, else_block = null) -> $Any {
        // Conditional execution
        
        if condition {
            scope.enter_new("if_block")
            let result = control.execute_block(then_block)
            scope.exit()
            return result
        } else if else_block != null {
            scope.enter_new("else_block")
            let result = control.execute_block(else_block)
            scope.exit()
            return result
        } else {
            return null
        }
    }

    /**
     * ITERATIVE LOOP CONTROL WITH SAFETY LIMITS
     * ==========================================
     * 
     * Implements while loop control with complete safety mechanisms,
     * scope management, and execution monitoring. This function provides
     * traditional while loop semantics enhanced with Hyphos ecosystem
     * integration and protection against infinite loops.
     * 
     * SAFETY MECHANISMS:
     * - Maximum iteration limit (10,000) prevents infinite loops
     * - Resource monitoring during loop execution
     * - Automatic termination on resource exhaustion
     * - Exception handling with proper scope cleanup
     * 
     * EXECUTION TRACKING:
     * - Collects results from each loop iteration
     * - Maintains iteration count for debugging and optimization
     * - Monitors execution time and resource consumption
     * - Provides detailed execution statistics on completion
     * 
     * SCOPE MANAGEMENT:
     * - Creates isolated scope for entire loop execution
     * - Each iteration executes within consistent scope context
     * - Automatic variable cleanup on loop completion
     * - Prevents memory leaks in long-running loops
     * 
     * PERFORMANCE OPTIMIZATION:
     * - Early termination on resource constraints
     * - Adaptive iteration scheduling based on system load
     * - Integration with energy management for power efficiency
     * - Consciousness-aware execution for intelligent loop behavior
     * 
     * @param condition_expr Boolean expression evaluated each iteration
     * @param loop_body Code block executed while condition remains true
     * @return $Array Collection of results from each loop iteration
     * 
     * @safety Maximum 10,000 iterations to prevent infinite loops
     * @scope_isolation Single scope for entire loop execution
     * @resource_monitoring Tracks memory and CPU usage during execution
     * @performance Adaptive scheduling based on system conditions
     * 
     * @example
     * invoke control:
     *     let data_queue = network.get_incoming_data_queue()
     *     let processed_results = while(data_queue.has_data(), {
     *         let data_item = data_queue.pop()
     *         let processed = ai.process_data(data_item)
     *         return processed
     *     })
     *     logger.info("Processed " + processed_results.length + " items")
     * transcend
     */
    fun while(condition_expr, loop_body) -> $Array {
        // While loop
        
        let loop_results = []
        let loop_count = 0
        let max_iterations = 10000  // Safety limit
        
        scope.enter_new("while_loop")
        
        while control.evaluate_expression(condition_expr) and loop_count < max_iterations {
            scope.enter_new("while_iteration_" + string.from(loop_count))
            let result = control.execute_block(loop_body)
            array.append(loop_results, result)
            scope.exit()
            loop_count = loop_count + 1
        }
        
        scope.exit()
        
        if loop_count >= max_iterations {
            error.throw("While loop exceeded maximum iterations: " + string.from(max_iterations))
        }
        
        return loop_results
    }

control.for = {
    // For loop with iterator
    iterator_name = args.0
    iterable = args.1
    loop_body = args.2
    
    loop_results = []
    
    scope.enter_new("for_loop")
    
    iterator_values = get_iterator_values(iterable)
    index = 0
    
    while index < iterator_values.length {
        scope.enter_new("for_iteration_" + index)
        
        // Declare iterator variable in loop scope
        variables.declare(iterator_name, type.of(iterator_values[index]), iterator_values[index])
        
        result = execute_block(loop_body)
        loop_results.append(result)
        
        scope.exit()
        index = index + 1
    }
    
    scope.exit()
    loop_results
}

control.switch = {
    // Switch statement
    value = args.0
    cases = args.1  // Array of {condition, action} pairs
    default_case = if args.length > 2 then args.2 else null
    
    scope.enter_new("switch_block")
    
    result = null
    matched = false
    
    case_index = 0
    while case_index < cases.length and not matched {
        current_case = cases[case_index]
        
        if value == current_case.condition {
            scope.enter_new("case_" + case_index)
            result = execute_block(current_case.action)
            scope.exit()
            matched = true
        }
        
        case_index = case_index + 1
    }
    
    if not matched and default_case != null {
        scope.enter_new("default_case")
        result = execute_block(default_case)
        scope.exit()
    }
    
    scope.exit()
    result
}

control.break = {
    // Break from loop
    loop_level = if args.length > 0 then args.0 else 1
    system.break_signal = {
        type: "break",
        level: loop_level,
        timestamp: sidereal.current_time()
    }
    null
}

control.continue = {
    // Continue to next iteration
    loop_level = if args.length > 0 then args.0 else 1
    system.continue_signal = {
        type: "continue", 
        level: loop_level,
        timestamp: sidereal.current_time()
    }
    null
}

control.return = {
    // Return from function
    value = if args.length > 0 then args.0 else null
    system.return_signal = {
        type: "return",
        value: value,
        timestamp: sidereal.current_time()
    }
    value
}

execute_block = {
    // Execute a block of statements
    block = args.0
    
    if type.of(block) == "function" {
        block()
    } else if type.of(block) == "array" {
        last_result = null
        statement_index = 0
        
        while statement_index < block.length {
            statement = block[statement_index]
            last_result = execute_statement(statement)
            
            // Check for control flow signals
            if system.break_signal != null or system.continue_signal != null or system.return_signal != null {
                break
            }
            
            statement_index = statement_index + 1
        }
        
        last_result
    } else {
        execute_statement(block)
    }
}

evaluate_expression = {
    // Evaluate a conditional expression
    expr = args.0
    
    if type.of(expr) == "function" {
        expr()
    } else if type.of(expr) == "boolean" {
        expr
    } else {
        // Convert to boolean
        expr != null and expr != false and expr != 0
    }
}

get_iterator_values = {
    // Get values to iterate over
    iterable = args.0
    
    if type.of(iterable) == "array" {
        iterable
    } else if type.of(iterable) == "range" {
        range.to_array(iterable)
    } else if type.of(iterable) == "string" {
        string.to_char_array(iterable)
    } else {
        error("Cannot iterate over type: " + type.of(iterable))
    }
}
