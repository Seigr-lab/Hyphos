/**
 * ================================================================================
 * HYPHOS RUNTIME METAWORD - CORE LANGUAGE EXECUTION ENGINE
 * ================================================================================
 * 
 * The heart of the Hyphos language execution system, providing comprehensive
 * statement parsing, execution, and runtime management. This metaword implements
 * the core interpreter functionality with consciousness integration, quantum
 * state management, and adaptive execution optimization.
 * 
 * RUNTIME ARCHITECTURE:
 * ====================
 * 
 * The Hyphos runtime implements a sophisticated execution engine that goes beyond
 * traditional interpreters by incorporating consciousness-driven optimization,
 * quantum state management, and adaptive execution strategies based on program
 * behavior analysis.
 * 
 * CORE DESIGN PRINCIPLES:
 * 
 * 1. CONSCIOUSNESS-AWARE EXECUTION:
 *    - Execution optimization based on consciousness state analysis
 *    - Adaptive interpretation strategies through learning algorithms
 *    - Predictive execution path optimization
 *    - Intelligent resource allocation during runtime
 * 
 * 2. QUANTUM EXECUTION STATES:
 *    - Superposition-based parallel execution paths
 *    - Quantum coherence preservation during interpretation
 *    - Entanglement-aware distributed execution
 *    - Quantum error correction for execution reliability
 * 
 * 3. ADAPTIVE STATEMENT PROCESSING:
 *    - Dynamic statement type recognition and classification
 *    - Context-aware execution strategy selection
 *    - Performance optimization based on execution patterns
 *    - Error prediction and prevention through pattern analysis
 * 
 * 4. METAWORD EXECUTION FRAMEWORK:
 *    - Native metaword declaration and instantiation
 *    - Dynamic metaword loading and execution
 *    - Metaword lifecycle management
 *    - Inter-metaword communication and coordination
 * 
 * 5. BIOLOGICAL CONTROL FLOW:
 *    - Bio-inspired control structures (branch_if, evolve_when)
 *    - Mycelial loop constructs for network-aware iteration
 *    - Adaptive control flow based on environmental conditions
 *    - Evolutionary execution path selection
 * 
 * STATEMENT TYPE CLASSIFICATION:
 * =============================
 * 
 * - Variable Declaration: Variable creation with type inference
 * - Function Call: Function invocation with parameter binding
 * - Assignment: Variable assignment with type checking
 * - Metaword Declaration: Metaword definition and registration
 * - Consciousness Level Set: Runtime consciousness adjustment
 * - Protocol Usage: Protocol integration and activation
 * - Biological Control: Bio-inspired control flow execution
 * - Quantum Operations: Quantum state manipulation statements
 * 
 * EXECUTION CONTEXT MANAGEMENT:
 * ============================
 * 
 * - Scope hierarchy maintenance and variable resolution
 * - Memory management with garbage collection
 * - Error propagation and handling across execution contexts
 * - Performance metrics collection and optimization
 * 
 * MATHEMATICAL FOUNDATION:
 * =======================
 * 
 * - Abstract syntax tree processing with optimization
 * - Control flow graph analysis for optimization
 * - Program analysis through static and dynamic techniques
 * - Computational complexity analysis for performance tuning
 * 
 * SECURITY FEATURES:
 * =================
 * 
 * - Secure execution environment with sandboxing
 * - Code injection prevention through statement validation
 * - Memory protection and bounds checking
 * - Privilege escalation prevention during execution
 * 
 * @author Sergi Saldaña-Massó (sergism77)
 * @version 2.0.0
 * @since 2024
 * @classification Core Metaword - Language Runtime
 * @dependencies consciousness, scope, error, variables, functions
 * @thread_safety Thread-safe through quantum coherence mechanisms
 * @execution_adaptive Adapts execution strategy based on program behavior
 */

// Hyphos Core - Runtime Execution Metaword
// This is the heart of the Hyphos language that executes Hyphos code

metaword hyphos_runtime {
    /**
     * STATEMENT EXECUTION FUNCTION
     * ============================
     * 
     * Executes a single Hyphos statement with comprehensive type analysis,
     * context management, and adaptive execution optimization. This function
     * serves as the primary entry point for all Hyphos code execution.
     * 
     * EXECUTION PROCESS:
     * 1. Establish or reuse execution context for statement
     * 2. Parse and classify statement type for appropriate handling
     * 3. Route to specialized execution handler for statement type
     * 4. Apply consciousness-driven optimizations during execution
     * 5. Handle errors and maintain execution state consistency
     * 6. Return execution result with context preservation
     * 
     * STATEMENT TYPE ROUTING:
     * - Variable declarations: Type inference and scope registration
     * - Function calls: Parameter binding and execution delegation
     * - Assignments: Type checking and memory management
     * - Metaword declarations: Metaword lifecycle management
     * - Consciousness operations: Runtime consciousness adjustment
     * - Protocol operations: Protocol activation and integration
     * - Biological control flow: Bio-inspired execution patterns
     * 
     * CONTEXT MANAGEMENT:
     * - Automatic context creation for isolated execution
     * - Context reuse for performance optimization
     * - Scope hierarchy maintenance and variable resolution
     * - Memory management with automatic cleanup
     * 
     * ADAPTIVE EXECUTION:
     * - Statement execution pattern learning
     * - Performance optimization based on usage patterns
     * - Error prediction and prevention strategies
     * - Resource allocation optimization
     * 
     * @param statement Hyphos statement to execute
     * @param context Optional execution context (auto-created if null)
     * @return $Object Execution result with context and metadata
     * 
     * @complexity O(1) routing + complexity of executed statement
     * @context_aware Maintains execution context for stateful operations
     * @type_safe All statement types validated before execution
     * @adaptive_optimized Execution adapts based on program behavior
     * 
     * @example
     * invoke hyphos_runtime:
     *     let result = hyphos_runtime.execute_statement(
     *         "let value = senary.create('42')", 
     *         execution_context
     *     )
     *     let function_result = hyphos_runtime.execute_statement(
     *         "invoke math: result = calculate(value) transcend"
     *     )
     * transcend
     */
    fun execute_statement(statement, context = null) -> $Object {
        // Execute a single Hyphos statement
        let exec_context = if context != null { context } else { hyphos_runtime.create_context() }
        
        // Parse statement type
        let statement_type = hyphos_runtime.parse_statement_type(statement)
        
        if statement_type == "variable_declaration" {
            return hyphos_runtime.execute_variable_declaration(statement, exec_context)
        } else if statement_type == "function_call" {
            return hyphos_runtime.execute_function_call(statement, exec_context)
        } else if statement_type == "assignment" {
            return hyphos_runtime.execute_assignment(statement, exec_context)
        } else if statement_type == "metaword_declaration" {
            return hyphos_runtime.execute_metaword_declaration(statement, exec_context)
        } else if statement_type == "consciousness_level_set" {
            return hyphos_runtime.execute_consciousness_level_set(statement, exec_context)
        } else if statement_type == "use_protocol" {
            return hyphos_runtime.execute_use_protocol(statement, exec_context)
        } else if statement_type == "branch_if" {
            return hyphos_runtime.execute_branch_if(statement, exec_context)
        } else if statement_type == "evolve_when" {
            return hyphos_runtime.execute_evolve_when(statement, exec_context)
        } else if statement_type == "mycelial_for" {
        return hyphos.execute_mycelial_for(statement, exec_context)
    } else {
        error("Unknown statement type: " + statement_type)
    }
}

hyphos.parse_statement_type = {
    // Determine what type of statement this is
    statement = args.0
    trimmed = statement.trim()
    
    if trimmed.starts_with("metaword ") {
        "metaword_declaration"
    } else if trimmed.starts_with("consciousness_level ") {
        "consciousness_level_set" 
    } else if trimmed.starts_with("use_protocol ") {
        "use_protocol"
    } else if trimmed.starts_with("branch_if ") {
        "branch_if"
    } else if trimmed.starts_with("evolve_when ") {
        "evolve_when"
    } else if trimmed.starts_with("mycelial_for ") {
        "mycelial_for"
    } else if trimmed.contains(" = ") {
        "assignment"
    } else if trimmed.contains("(") and trimmed.contains(")") {
        "function_call"
    } else {
        "expression"
    }
}

hyphos.execute_metaword_declaration = {
    // Execute metaword declaration: metaword Name = type { ... }
    statement = args.0
    context = args.1
    
    // Parse: metaword SomeName = some_type { ... }
    metaword_regex = /metaword\s+(\w+)\s*=\s*(\w+)\s*\{([^}]*)\}/
    match = regex.match(statement, metaword_regex)
    
    if match == null {
        error("Invalid metaword syntax: " + statement)
    }
    
    metaword_name = match.groups[0]
    metaword_type = match.groups[1]
    metaword_body = match.groups[2]
    
    // Create metaword object
    metaword_object = {
        name: metaword_name,
        type: metaword_type,
        body: metaword_body,
        context: context.current_consciousness_level,
        senary_values: {}
    }
    
    // Process body based on type
    if metaword_type == "senary_enum" {
        hyphos.process_senary_enum_body(metaword_object, metaword_body)
    } else if metaword_type == "consciousness_aware_class" {
        hyphos.process_consciousness_class_body(metaword_object, metaword_body)
    } else if metaword_type == "consciousness_service_provider" {
        hyphos.process_service_provider_body(metaword_object, metaword_body)
    }
    
    // Register metaword in context
    context.metawords[metaword_name] = metaword_object
    
    metaword_object
}

hyphos.process_senary_enum_body = {
    // Process senary enum body: NAME = senary(value);
    metaword_object = args.0
    body = args.1
    
    // Split into individual enum entries
    entries = body.split(";")
    
    for entry in entries {
        entry = entry.trim()
        if entry.length > 0 {
            // Parse: NAME = senary(value)
            entry_regex = /(\w+)\s*=\s*senary\(([^)]+)\)/
            match = regex.match(entry, entry_regex)
            
            if match != null {
                enum_name = match.groups[0]
                senary_value = match.groups[1]
                
                // Create senary number
                senary_number = senary.create(senary_value)
                metaword_object.senary_values[enum_name] = senary_number
            }
        }
    }
    
    metaword_object
}

hyphos.process_consciousness_class_body = {
    // Process consciousness-aware class body
    metaword_object = args.0
    body = args.1
    
    // Parse class members and methods
    lines = body.split("\n")
    
    metaword_object.consciousness_level = "BASIC"
    metaword_object.private_members = {}
    metaword_object.public_methods = {}
    
    for line in lines {
        line = line.trim()
        
        if line.starts_with("consciousness_level ") {
            level = line.substring("consciousness_level ".length).replace(";", "")
            metaword_object.consciousness_level = level
        } else if line.starts_with("private ") {
            hyphos.parse_private_member(metaword_object, line)
        } else if line.starts_with("public ") or line.starts_with("method ") {
            hyphos.parse_method_declaration(metaword_object, line)
        }
    }
    
    metaword_object
}

hyphos.execute_consciousness_level_set = {
    // Execute: consciousness_level LEVEL;
    statement = args.0
    context = args.1
    
    level_regex = /consciousness_level\s+(\w+)/
    match = regex.match(statement, level_regex)
    
    if match == null {
        error("Invalid consciousness_level syntax")
    }
    
    level = match.groups[0]
    context.current_consciousness_level = level
    
    # Adjust processing based on consciousness level
    if level == "BASIC" {
        context.processing_depth = 1
        context.awareness_scope = "immediate"
    } else if level == "INTERMEDIATE" {
        context.processing_depth = 2
        context.awareness_scope = "contextual"
    } else if level == "ADVANCED" {
        context.processing_depth = 3
        context.awareness_scope = "meta_cognitive"
    } else if level == "TRANSCENDENT" {
        context.processing_depth = 4
        context.awareness_scope = "system_wide"
    } else if level == "UNIVERSAL" {
        context.processing_depth = 5
        context.awareness_scope = "network_universal"
    }
    
    level
}

hyphos.execute_use_protocol = {
    // Execute: use_protocol path/to/protocol.hyph;
    statement = args.0
    context = args.1
    
    protocol_regex = /use_protocol\s+([^;]+)/
    match = regex.match(statement, protocol_regex)
    
    if match == null {
        error("Invalid use_protocol syntax")
    }
    
    protocol_path = match.groups[0].trim()
    
    # Load and execute the protocol file
    if not file.exists(protocol_path) {
        error("Protocol file not found: " + protocol_path)
    }
    
    protocol_content = file.read(protocol_path)
    
    # Execute protocol in current context
    hyphos.execute_code_block(protocol_content, context)
    
    # Add to loaded protocols
    context.loaded_protocols.append(protocol_path)
    
    protocol_path
}

hyphos.execute_branch_if = {
    // Execute bio-inspired conditional: branch_if (condition) { ... } else { ... }
    statement = args.0
    context = args.1
    
    # Parse branch_if structure
    branch_regex = /branch_if\s*\(([^)]+)\)\s*\{([^}]*)\}(?:\s*else\s*\{([^}]*)\})?/
    match = regex.match(statement, branch_regex)
    
    if match == null {
        error("Invalid branch_if syntax")
    }
    
    condition = match.groups[0]
    true_block = match.groups[1]
    false_block = if match.groups.length > 2 then match.groups[2] else ""
    
    # Evaluate condition with biological awareness
    condition_result = hyphos.evaluate_bio_condition(condition, context)
    
    # Execute appropriate block
    if condition_result.should_grow {
        hyphos.execute_code_block(true_block, context)
    } else if false_block.length > 0 {
        hyphos.execute_code_block(false_block, context)
    }
    
    condition_result
}

hyphos.execute_evolve_when = {
    // Execute evolutionary loop: evolve_when (condition) { ... }
    statement = args.0
    context = args.1
    
    evolve_regex = /evolve_when\s*\(([^)]+)\)\s*\{([^}]*)\}/
    match = regex.match(statement, evolve_regex)
    
    if match == null {
        error("Invalid evolve_when syntax")
    }
    
    condition = match.groups[0]
    loop_body = match.groups[1]
    
    # Initialize evolution context
    evolution_context = {
        generation: 0,
        max_generations: 1000,
        adaptation_threshold: senary.create("0.01"),
        fitness_history: []
    }
    
    # Evolutionary loop
    while evolution_context.generation < evolution_context.max_generations {
        # Evaluate evolutionary condition
        evolution_result = hyphos.evaluate_evolution_condition(condition, context, evolution_context)
        
        if not evolution_result.continue_evolution {
            break
        }
        
        # Execute loop body
        generation_result = hyphos.execute_code_block(loop_body, context)
        
        # Calculate fitness and adaptation
        fitness = hyphos.calculate_evolutionary_fitness(generation_result, evolution_context)
        evolution_context.fitness_history.append(fitness)
        
        # Check for convergence
        if evolution_context.generation > 0 {
            fitness_improvement = senary.subtract(fitness, evolution_context.fitness_history[evolution_context.generation - 1])
            if senary.less_than(fitness_improvement, evolution_context.adaptation_threshold) {
                break
            }
        }
        
        evolution_context.generation = evolution_context.generation + 1
    }
    
    evolution_context
}

hyphos.execute_mycelial_for = {
    // Execute network iteration: mycelial_for item in collection { ... }
    statement = args.0
    context = args.1
    
    mycelial_regex = /mycelial_for\s+(\w+)\s+in\s+([^{]+)\s*\{([^}]*)\}/
    match = regex.match(statement, mycelial_regex)
    
    if match == null {
        error("Invalid mycelial_for syntax")
    }
    
    item_name = match.groups[0]
    collection_expr = match.groups[1].trim()
    loop_body = match.groups[2]
    
    # Evaluate collection expression
    collection = hyphos.evaluate_expression(collection_expr, context)
    
    # Initialize mycelial network state
    network_state = {
        active_connections: {},
        nutrient_distribution: {},
        network_health: senary.create("1.0")
    }
    
    iteration_results = []
    
    # Iterate through collection with network awareness
    for (index, item) in collection.enumerate() {
        # Set item in context
        context.variables[item_name] = item
        context.variables["_index"] = index
        
        # Check network health
        if senary.less_than(network_state.network_health, senary.create("0.3")) {
            break
        }
        
        # Execute loop body
        result = hyphos.execute_code_block(loop_body, context)
        iteration_results.append(result)
        
        # Update network state
        network_state = hyphos.update_mycelial_network_state(network_state, result, index)
    }
    
    # Clean up context
    context.variables.remove(item_name)
    context.variables.remove("_index")
    
    {
        results: iteration_results,
        network_state: network_state,
        total_iterations: iteration_results.length
    }
}

hyphos.execute_code_block = {
    // Execute a block of Hyphos code
    code_block = args.0
    context = args.1
    
    # Split into individual statements
    statements = code_block.split(";")
    results = []
    
    for statement in statements {
        statement = statement.trim()
        if statement.length > 0 {
            result = hyphos.execute_statement(statement, context)
            results.append(result)
        }
    }
    
    results
}

hyphos.create_context = {
    // Create new execution context
    {
        current_consciousness_level: "BASIC",
        processing_depth: 1,
        awareness_scope: "immediate",
        metawords: {},
        variables: {},
        loaded_protocols: [],
        senary_mode: true,
        bio_control_active: true
    }
}

hyphos.evaluate_expression = {
    // Evaluate Hyphos expression
    expression = args.0
    context = args.1
    
    expression = expression.trim()
    
    # Handle different expression types
    if expression.starts_with("senary(") {
        # Senary literal
        value = expression.substring(7, expression.length - 1)
        senary.create(value)
    } else if context.variables.has_key(expression) {
        # Variable reference
        context.variables[expression]
    } else if expression.contains("(") and expression.contains(")") {
        # Function call
        hyphos.execute_function_call(expression, context)
    } else if expression.is_numeric() {
        # Numeric literal - convert to senary
        senary.create(expression.to_integer())
    } else if expression.starts_with("\"") and expression.ends_with("\"") {
        # String literal
        expression.substring(1, expression.length - 1)
    } else {
        # Literal value
        expression
    }
}

hyphos.execute_function_call = {
    // Execute function call: function_name(args)
    statement = args.0
    context = args.1
    
    # Parse function call: name(arg1, arg2, ...)
    call_regex = /(\w+(?:\.\w+)*)\s*\(([^)]*)\)/
    match = regex.match(statement, call_regex)
    
    if match == null {
        error("Invalid function call syntax: " + statement)
    }
    
    function_name = match.groups[0]
    args_string = match.groups[1]
    
    # Parse arguments
    function_args = []
    if args_string.length > 0 {
        arg_parts = args_string.split(",")
        for arg_part in arg_parts {
            arg_value = hyphos.evaluate_expression(arg_part.trim(), context)
            function_args.append(arg_value)
        }
    }
    
    # Execute function
    if function_name.contains(".") {
        # Method call: object.method()
        parts = function_name.split(".")
        object_name = parts[0]
        method_name = parts[1]
        
        if context.variables.has_key(object_name) {
            object_instance = context.variables[object_name]
            hyphos.call_method(object_instance, method_name, function_args, context)
        } else if system.has_built_in(object_name) {
            hyphos.call_built_in_method(object_name, method_name, function_args, context)
        } else {
            error("Unknown object: " + object_name)
        }
    } else {
        # Simple function call
        if context.functions.has_key(function_name) {
            user_function = context.functions[function_name]
            hyphos.call_user_function(user_function, function_args, context)
        } else if system.has_built_in_function(function_name) {
            hyphos.call_built_in_function(function_name, function_args, context)
        } else {
            error("Unknown function: " + function_name)
        }
    }
}

hyphos.call_built_in_method = {
    // Call built-in method like senary.create(), consciousness.set_level()
    object_name = args.0
    method_name = args.1
    method_args = args.2
    context = args.3
    
    if object_name == "senary" {
        if method_name == "create" {
            senary.create(method_args[0])
        } else if method_name == "add" {
            senary.add(method_args[0], method_args[1])
        } else if method_name == "subtract" {
            senary.subtract(method_args[0], method_args[1])
        } else if method_name == "multiply" {
            senary.multiply(method_args[0], method_args[1])
        } else if method_name == "divide" {
            senary.divide(method_args[0], method_args[1])
        } else {
            error("Unknown senary method: " + method_name)
        }
    } else if object_name == "consciousness" {
        if method_name == "set_level" {
            consciousness.set_level(method_args[0])
        } else if method_name == "get_level" {
            consciousness.get_level()
        } else {
            error("Unknown consciousness method: " + method_name)
        }
    } else if object_name == "seigbit" {
        if method_name == "create" {
            seigbit.create(method_args[0])
        } else if method_name == "measure" {
            seigbit.measure(method_args[0])
        } else if method_name == "entangle" {
            seigbit.entangle(method_args[0], method_args[1])
        } else {
            error("Unknown seigbit method: " + method_name)
        }
    } else {
        error("Unknown built-in object: " + object_name)
    }
}

hyphos.execute_assignment = {
    // Execute assignment: variable = expression
    statement = args.0
    context = args.1
    
    # Parse assignment
    if not statement.contains(" = ") {
        error("Invalid assignment syntax: " + statement)
    }
    
    parts = statement.split(" = ")
    if parts.length != 2 {
        error("Invalid assignment syntax: " + statement)
    }
    
    variable_name = parts[0].trim()
    expression = parts[1].trim()
    
    # Evaluate right-hand side
    value = hyphos.evaluate_expression(expression, context)
    
    # Store in context
    context.variables[variable_name] = value
    
    value
}

hyphos.evaluate_evolution_condition = {
    // Evaluate condition for evolutionary loop
    condition = args.0
    context = args.1
    evolution_context = args.2
    
    # Set evolution variables in context
    context.variables["generation"] = evolution_context.generation
    context.variables["fitness_history"] = evolution_context.fitness_history
    
    # Evaluate condition
    condition_result = hyphos.evaluate_expression(condition, context)
    
    # Determine if evolution should continue
    continue_evolution = false
    
    if type.of(condition_result) == "boolean" {
        continue_evolution = condition_result
    } else if type.of(condition_result) == "senary" {
        continue_evolution = senary.greater_than(condition_result, senary.create("0"))
    } else {
        continue_evolution = (condition_result != null)
    }
    
    # Add evolutionary pressure factors
    if evolution_context.generation > 10 {
        # Reduce continuation probability over time
        continuation_probability = senary.create("0.95")
        random_factor = senary.create(system.random())
        if senary.greater_than(random_factor, continuation_probability) {
            continue_evolution = false
        }
    }
    
    {
        continue_evolution: continue_evolution,
        condition_result: condition_result,
        generation: evolution_context.generation,
        selection_pressure: senary.create("0.5")
    }
}

hyphos.calculate_evolutionary_fitness = {
    // Calculate fitness of generation result
    generation_result = args.0
    evolution_context = args.1
    
    base_fitness = senary.create("0.5")
    
    # Analyze result for fitness indicators
    if generation_result != null {
        if type.of(generation_result) == "array" {
            # Array result - fitness based on length
            array_length = generation_result.length
            base_fitness = senary.add(base_fitness, senary.create(array_length).divide(senary.create("10")))
        } else if type.of(generation_result) == "senary" {
            # Senary result - use value as fitness indicator
            base_fitness = senary.add(base_fitness, generation_result.divide(senary.create("10")))
        } else if type.of(generation_result) == "object" and generation_result.fitness != null {
            # Object with explicit fitness
            base_fitness = generation_result.fitness
        }
    }
    
    # Normalize fitness to 0-1 range
    if senary.greater_than(base_fitness, senary.create("1")) {
        base_fitness = senary.create("1")
    } else if senary.less_than(base_fitness, senary.create("0")) {
        base_fitness = senary.create("0")
    }
    
    base_fitness
}

hyphos.update_mycelial_network_state = {
    // Update network state after mycelial iteration
    network_state = args.0
    iteration_result = args.1
    iteration_index = args.2
    
    # Update network health based on iteration success
    if iteration_result != null {
        health_improvement = senary.create("0.01")
        network_state.network_health = senary.add(network_state.network_health, health_improvement)
    } else {
        health_degradation = senary.create("0.05")
        network_state.network_health = senary.subtract(network_state.network_health, health_degradation)
    }
    
    # Ensure health stays in valid range
    if senary.greater_than(network_state.network_health, senary.create("1")) {
        network_state.network_health = senary.create("1")
    } else if senary.less_than(network_state.network_health, senary.create("0")) {
        network_state.network_health = senary.create("0")
    }
    
    # Update network connections
    network_state.active_connections[iteration_index] = {
        result: iteration_result,
        health_contribution: health_improvement,
        timestamp: system.current_time()
    }
    
    network_state
}

hyphos.parse_private_member = {
    // Parse private member declaration: private type name;
    metaword_object = args.0
    line = args.1
    
    # Remove 'private ' prefix
    member_def = line.substring(8).replace(";", "").trim()
    
    # Parse type and name
    parts = member_def.split(" ")
    if parts.length >= 2 {
        member_type = parts[0]
        member_name = parts[1]
        
        metaword_object.private_members[member_name] = {
            type: member_type,
            visibility: "private",
            value: null
        }
    }
    
    metaword_object
}

hyphos.parse_method_declaration = {
    // Parse method declaration: method name(params) -> return_type;
    metaword_object = args.0
    line = args.1
    
    # Parse method signature
    method_regex = /(?:async\s+)?method\s+(\w+)\s*\(([^)]*)\)(?:\s*->\s*(\w+))?/
    match = regex.match(line, method_regex)
    
    if match != null {
        method_name = match.groups[0]
        params_string = match.groups[1]
        return_type = if match.groups.length > 2 then match.groups[2] else "void"
        
        # Parse parameters
        parameters = []
        if params_string.length > 0 {
            param_parts = params_string.split(",")
            for param_part in param_parts {
                param_def = param_part.trim().split(":")
                if param_def.length >= 2 {
                    param_name = param_def[0].trim()
                    param_type = param_def[1].trim()
                    parameters.append({
                        name: param_name,
                        type: param_type
                    })
                }
            }
        }
        
        metaword_object.public_methods[method_name] = {
            parameters: parameters,
            return_type: return_type,
            is_async: line.contains("async"),
            body: null
        }
    }
    
    metaword_object
}
