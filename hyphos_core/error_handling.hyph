/**
 * ================================================================================
 * HYPHOS ERROR HANDLING METAWORD - COMPREHENSIVE EXCEPTION MANAGEMENT
 * ================================================================================
 * 
 * Advanced error handling and exception management system for the Hyphos language.
 * This metaword provides comprehensive error management capabilities including
 * structured exception handling, error recovery mechanisms, and integration with
 * the consciousness system for adaptive error response.
 * 
 * ERROR HANDLING ARCHITECTURE:
 * ===========================
 * 
 * The error handling system implements a multi-layered approach to exception
 * management, combining traditional try-catch mechanisms with consciousness-driven
 * adaptive responses and quantum-inspired error recovery protocols.
 * 
 * CORE DESIGN PRINCIPLES:
 * 
 * 1. STRUCTURED EXCEPTION HANDLING:
 *    - Hierarchical error type classification
 *    - Comprehensive error context preservation
 *    - Stack trace analysis and reporting
 *    - Correlation ID tracking for distributed debugging
 * 
 * 2. CONSCIOUSNESS-DRIVEN ERROR RESPONSE:
 *    - Adaptive error recovery based on learned patterns
 *    - Intelligent error escalation through consciousness levels
 *    - Predictive error prevention using pattern analysis
 *    - Self-healing capabilities for common error scenarios
 * 
 * 3. QUANTUM ERROR CORRECTION:
 *    - Quantum state preservation during error conditions
 *    - Superposition-based error recovery strategies
 *    - Entanglement-preserved error propagation
 *    - Coherence maintenance under exception conditions
 * 
 * 4. DISTRIBUTED ERROR COORDINATION:
 *    - Cross-cell error communication and coordination
 *    - Swarm intelligence for collective error resolution
 *    - Mycelial network error propagation control
 *    - Distributed recovery strategy coordination
 * 
 * 5. TEMPORAL ERROR ANALYSIS:
 *    - Sidereal time-based error correlation
 *    - Temporal pattern analysis for error prediction
 *    - Historical error trend analysis
 *    - Time-based error recovery scheduling
 * 
 * ERROR CLASSIFICATION SYSTEM:
 * ===========================
 * 
 * - RuntimeError: Standard execution errors with recovery potential
 * - CriticalError: System-threatening errors requiring immediate attention
 * - FatalError: Unrecoverable errors requiring system restart
 * - Warning: Non-fatal issues that may indicate future problems
 * - QuantumError: Quantum state corruption or coherence failures
 * - ConsciousnessError: Consciousness processing failures
 * - NetworkError: Mycelial network communication failures
 * 
 * MATHEMATICAL FOUNDATION:
 * =======================
 * 
 * - Senary arithmetic for error code representation
 * - Probability theory for error prediction algorithms
 * - Graph theory for error propagation analysis
 * - Information theory for error recovery optimization
 * 
 * SECURITY CONSIDERATIONS:
 * =======================
 * 
 * - Secure error message sanitization
 * - Stack trace information protection
 * - Error-based attack prevention
 * - Privilege escalation protection during error handling
 * 
 * @author Sergi Saldaña-Massó (sergism77)
 * @version 2.0.0
 * @since 2024
 * @classification Core Metaword - Exception Management
 * @dependencies logger, sidereal_time, scope, system, consciousness
 * @thread_safety Thread-safe through quantum coherence mechanisms
 * @recovery_capable Supports automatic error recovery and adaptation
 */

// Hyphos Core - Error Metaword
// Core error management and exception handling for Hyphos language

metaword error {
    /**
     * ERROR THROWING FUNCTION
     * ======================
     * 
     * Creates and throws a structured error with comprehensive context information.
     * This function implements the core error creation mechanism with support for
     * different error types, severity levels, and detailed contextual data.
     * 
     * ERROR OBJECT STRUCTURE:
     * 1. Type classification for appropriate handling strategies
     * 2. Human-readable message for debugging and user feedback
     * 3. Structured data payload for programmatic error analysis
     * 4. Temporal context using sidereal time for correlation
     * 5. Scope level information for execution context
     * 6. Stack trace for detailed debugging information
     * 7. Correlation ID for distributed error tracking
     * 
     * SEVERITY MAPPING:
     * - RuntimeError: ERROR level - Standard recoverable errors
     * - CriticalError: CRITICAL level - System-threatening conditions
     * - FatalError: FATAL level - Unrecoverable system failures
     * - Warning: WARNING level - Non-fatal advisory conditions
     * - Custom types: ERROR level (default fallback)
     * 
     * LOGGING INTEGRATION:
     * - Automatic logging to system logger with appropriate severity
     * - Structured logging with error metadata for analysis
     * - Correlation ID tracking for distributed system debugging
     * - Alert severity determination for monitoring systems
     * 
     * SYSTEM STATE MANAGEMENT:
     * - Updates global error state for error propagation
     * - Sets error flags for exception handling mechanisms
     * - Preserves error context for recovery operations
     * - Maintains error history for pattern analysis
     * 
     * @param message Human-readable error description
     * @param error_data Optional structured data payload for error context
     * @param error_type Error classification (RuntimeError, CriticalError, etc.)
     * @return $Object Comprehensive error object with full context
     * 
     * @complexity O(1) error creation with logging overhead
     * @thread_safe Error creation is atomic and thread-safe
     * @audit_logged All errors are automatically logged for security analysis
     * @correlation_tracked Each error receives unique correlation ID
     * 
     * @example
     * invoke error:
     *     let validation_error = throw("Invalid senary number format", 
     *                                  {input: "invalid_data", expected: "senary"},
     *                                  "RuntimeError")
     *     // Error is automatically logged and system state updated
     * transcend
     */
    fun throw(message, error_data = null, error_type = "RuntimeError") -> $Object {
        // Throw an error with message and optional data
        
        let alert_severity = match error_type {
            case "RuntimeError" -> logger.ERROR
            case "CriticalError" -> logger.CRITICAL  
            case "FatalError" -> logger.FATAL
            case "Warning" -> logger.WARNING
            case _ -> logger.ERROR
        }
        
        let error_object = {
            type: error_type,
            message: message,
            data: error_data,
            timestamp: sidereal_time.current_time(),
            scope_level: scope.current_level(),
            stack_trace: error.get_stack_trace(),
            alert_severity: alert_severity,
            correlation_id: system.generate_uuid()
        }
        
        // Log using native logger
        logger.log_event(
            alert_severity,
            "HyphosRuntime", 
            "Hyphos Error: " + message,
            false,
            {
                error_type: error_type,
                scope_level: scope.current_level(),
                correlation_id: error_object.correlation_id
            }
        )
        
        system.current_error = error_object
        system.error_thrown = true
        
        return error_object
    }

    /**
     * TRY-CATCH-FINALLY EXCEPTION HANDLING FUNCTION
     * =============================================
     * 
     * Implements structured exception handling with support for try-catch-finally
     * blocks, providing comprehensive error recovery and resource cleanup capabilities.
     * This function forms the foundation of Hyphos exception handling architecture.
     * 
     * EXECUTION FLOW:
     * 1. Clear previous error state and prepare execution context
     * 2. Create isolated scope for try block execution
     * 3. Execute try block with error monitoring
     * 4. If error occurs, execute catch block with error context
     * 5. Always execute finally block for cleanup operations
     * 6. Restore previous scope and return appropriate result
     * 
     * ERROR HANDLING STRATEGY:
     * - Automatic error detection through system error flags
     * - Error context preservation for catch block processing
     * - Scope isolation to prevent error propagation
     * - Resource cleanup guarantee through finally block
     * 
     * SCOPE MANAGEMENT:
     * - Creates isolated scope for try block execution
     * - Preserves error context across scope boundaries
     * - Ensures proper scope cleanup in all execution paths
     * - Maintains scope stack integrity during exceptions
     * 
     * AUDIT LOGGING:
     * - Try block execution start and completion logging
     * - Error occurrence logging with full context
     * - Finally block execution logging for compliance
     * - Performance metrics for exception handling analysis
     * 
     * CONSCIOUSNESS INTEGRATION:
     * - Error pattern learning for future prevention
     * - Adaptive error recovery strategy selection
     * - Consciousness-driven error escalation decisions
     * - Machine learning from error handling outcomes
     * 
     * @param try_block Function containing code to execute with error monitoring
     * @param catch_block Optional error handler function (receives error object)
     * @param finally_block Optional cleanup function (always executed)
     * @return $Any Result from try block on success, catch block result on error
     * 
     * @complexity O(1) + complexity of executed blocks
     * @scope_isolated Try block executes in isolated scope for safety
     * @cleanup_guaranteed Finally block always executes for resource cleanup
     * @error_preserving Full error context preserved for catch block analysis
     * 
     * @example
     * invoke error:
     *     let result = try(
     *         fun() { return risky_operation() },
     *         fun(error) { 
     *             logger.warning("Operation failed", error.message)
     *             return default_value 
     *         },
     *         fun() { cleanup_resources() }
     *     )
     * transcend
     */
    fun try(try_block, catch_block = null, finally_block = null) -> $Any {
        // Try to execute code block with error handling
    let result = null
    let error_occurred = false
    
    // Clear any previous error state  
    system.current_error = null
    system.error_thrown = false
    
    scope.enter_new("try_block")
    
    // Log try block execution start
    logger.log_audit_event(
        severity: AlertSeverity.ALERT_SEVERITY_INFO,
        category: "HyphosRuntime",
        message: "Try block execution started",
        sensitive: false,
        scope_level: scope.current_level()
    )
    
    // Execute try block
    result = execute_block(try_block)
    
    // Check if error was thrown during execution
    if system.error_thrown {
        error_occurred = true
        
        // Log error caught
        logger.log_audit_event(
            severity: AlertSeverity.ALERT_SEVERITY_WARNING,
            category: "HyphosRuntime", 
            message: "Error caught in try block: " + system.current_error.message,
            sensitive: false,
            error_type: system.current_error.type,
            scope_level: scope.current_level()
        )
        
        if catch_block != null {
            scope.enter_new("catch_block")
            
            // Make error available in catch block
            variables.declare("error", "object", system.current_error)
            
            result = execute_block(catch_block)
            
            scope.exit()
        }
        
        // Clear error state after handling
        system.current_error = null
        system.error_thrown = false
    }
    
    scope.exit()
    
    // Execute finally block if present
    if finally_block != null {
        scope.enter_new("finally_block")
        execute_block(finally_block)
        scope.exit()
    }
    
    result
}

error.catch = {
    // Catch specific error types
    error_types = args.0  // Array of error types to catch
    catch_block = args.1
    
    if not system.error_thrown {
        error("No error to catch")
    }
    
    current_error = system.current_error
    
    // Check if current error type matches any specified types
    type_matches = false
    
    type_index = 0
    while type_index < error_types.length and not type_matches {
        if current_error.type == error_types[type_index] {
            type_matches = true
        }
        type_index = type_index + 1
    }
    
    if type_matches {
        scope.enter_new("specific_catch")
        variables.declare("error", "object", current_error)
        result = execute_block(catch_block)
        scope.exit()
        
        system.current_error = null
        system.error_thrown = false
        
        result
    } else {
        // Re-throw if type doesn't match
        error.rethrow()
    }
}

error.rethrow = {
    // Re-throw current error
    if not system.error_thrown {
        error("No error to rethrow")
    }
    
    // Error state remains unchanged
    system.current_error
}

error.get_stack_trace = {
    // Get current execution stack trace
    stack_trace = []
    
    scope_index = system.scope_stack.length - 1
    while scope_index >= 0 {
        scope_entry = system.scope_stack[scope_index]
        
        stack_trace.append({
            scope_name: scope_entry.name,
            scope_level: scope_index,
            creation_time: scope_entry.creation_time
        })
        
        scope_index = scope_index - 1
    }
    
    stack_trace
}

error.log = {
    // Log error to system error log
    error_object = args.0
    log_level = if args.length > 1 then args.1 else "ERROR"
    
    log_entry = {
        level: log_level,
        timestamp: sidereal.current_time(),
        error_type: error_object.type,
        message: error_object.message,
        scope_level: error_object.scope_level,
        stack_trace: error_object.stack_trace
    }
    
    system.error_log.append(log_entry)
    log_entry
}

error.get_last = {
    // Get last error that occurred
    system.current_error
}

error.clear = {
    // Clear current error state
    system.current_error = null
    system.error_thrown = false
    true
}

error.assert = {
    // Assert condition is true, throw error if false
    condition = args.0
    message = if args.length > 1 then args.1 else "Assertion failed"
    
    if not condition {
        error.throw(message, null, "AssertionError")
    }
    
    true
}

error.validate_args = {
    // Validate function arguments
    args_array = args.0
    expected_count = args.1
    arg_types = if args.length > 2 then args.2 else null
    
    // Check argument count
    if args_array.length != expected_count {
        error.throw("Invalid argument count: expected " + expected_count + ", got " + args_array.length, null, "ArgumentError")
    }
    
    // Check argument types if specified
    if arg_types != null {
        arg_index = 0
        while arg_index < args_array.length {
            expected_type = arg_types[arg_index]
            actual_type = type.of(args_array[arg_index])
            
            if not type.compatible(expected_type, actual_type) {
                error.throw("Invalid argument type at position " + arg_index + ": expected " + expected_type + ", got " + actual_type, null, "TypeError")
            }
            
            arg_index = arg_index + 1
        }
    }
    
    true
}

error.create_custom = {
    // Create custom error type
    error_type_name = args.0
    default_message = if args.length > 1 then args.1 else "Custom error occurred"
    
    custom_error_type = {
        name: error_type_name,
        default_message: default_message,
        creation_time: sidereal.current_time(),
        instance_count: 0
    }
    
    system.custom_error_types[error_type_name] = custom_error_type
    custom_error_type
}

error.throw_custom = {
    // Throw custom error type
    error_type_name = args.0
    message = if args.length > 1 then args.1 else null
    error_data = if args.length > 2 then args.2 else null
    
    custom_error_type = system.custom_error_types[error_type_name]
    if custom_error_type == null {
        error.throw("Unknown custom error type: " + error_type_name, null, "UnknownErrorType")
    }
    
    final_message = if message != null then message else custom_error_type.default_message
    custom_error_type.instance_count = custom_error_type.instance_count + 1
    
    error.throw(final_message, error_data, error_type_name)
}

error.get_log = {
    // Get error log entries
    max_entries = if args.length > 0 then args.0 else system.error_log.length
    
    start_index = if system.error_log.length > max_entries then system.error_log.length - max_entries else 0
    
    log_subset = []
    index = start_index
    while index < system.error_log.length {
        log_subset.append(system.error_log[index])
        index = index + 1
    }
    
    log_subset
}

error.clear_log = {
    // Clear error log
    system.error_log = []
    true
}
