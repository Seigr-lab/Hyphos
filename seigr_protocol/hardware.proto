syntax = "proto3";

package seigr.hardware;

import "seigr_timestamp.proto";
import "common.proto";

/**
 * Seigr Universal Hardware Abstraction Protocol
 * 
 * Complete hardware-agnostic interface supporting any platform.
 * From Raspberry Pi to x86, ARM to RISC-V - Seigr runs everywhere.
 * 
 * Philosophy:
 * - Platform-agnostic hardware interface
 * - Senary-optimized hardware communication
 * - Energy-aware hardware management
 * - Protocol-driven capability discovery
 * - Zero hardware vendor lock-in
 */

// ===========================
// ENUMS
// ===========================

/**
 * Supported hardware platforms
 */
enum HardwarePlatform {
    PLATFORM_UNKNOWN = 0;
    PLATFORM_RASPBERRY_PI = 1;     // Raspberry Pi (all models)
    PLATFORM_X86_64 = 2;          // Intel/AMD x86_64
    PLATFORM_ARM64 = 3;           // ARM 64-bit
    PLATFORM_ARM32 = 4;           // ARM 32-bit
    PLATFORM_RISC_V = 5;          // RISC-V architecture
    PLATFORM_EMBEDDED = 6;        // Generic embedded systems
    PLATFORM_VIRTUAL = 7;         // Virtual/emulated hardware
}

/**
 * GPIO pin modes (senary-optimized)
 */
enum GPIOMode {
    GPIO_INPUT = 0;               // Input mode
    GPIO_OUTPUT = 1;              // Output mode
    GPIO_PWM = 2;                 // PWM output
    GPIO_SPI = 3;                 // SPI communication
    GPIO_I2C = 4;                 // I2C communication
    GPIO_UART = 5;                // UART communication
}

/**
 * GPIO pin values (senary representation)
 */
enum GPIOValue {
    GPIO_LOW = 0;                 // Low/0V
    GPIO_HIGH = 1;                // High/3.3V or 5V
    GPIO_FLOATING = 2;            // High impedance
    GPIO_PWM_0 = 3;               // PWM level 0 (senary)
    GPIO_PWM_3 = 4;               // PWM level 3 (senary)
    GPIO_PWM_5 = 5;               // PWM level 5 (senary)
}

/**
 * Sensor types
 */
enum SensorType {
    SENSOR_TEMPERATURE = 0;
    SENSOR_HUMIDITY = 1;
    SENSOR_PRESSURE = 2;
    SENSOR_LIGHT = 3;
    SENSOR_MOTION = 4;
    SENSOR_SOUND = 5;
    SENSOR_MAGNETIC = 6;
    SENSOR_ACCELERATION = 7;
    SENSOR_GYROSCOPE = 8;
    SENSOR_GPS = 9;
    SENSOR_CUSTOM = 10;
}

/**
 * Communication protocols
 */
enum CommProtocol {
    PROTOCOL_GPIO = 0;
    PROTOCOL_SPI = 1;
    PROTOCOL_I2C = 2;
    PROTOCOL_UART = 3;
    PROTOCOL_USB = 4;
    PROTOCOL_ETHERNET = 5;
    PROTOCOL_WIFI = 6;
    PROTOCOL_BLUETOOTH = 7;
    PROTOCOL_CAN = 8;
    PROTOCOL_CUSTOM = 9;
}

/**
 * Power management states
 */
enum PowerState {
    POWER_FULL = 0;               // Full power mode
    POWER_REDUCED = 1;            // Reduced power mode
    POWER_SLEEP = 2;              // Sleep mode
    POWER_DEEP_SLEEP = 3;         // Deep sleep mode
    POWER_HIBERNATE = 4;          // Hibernation mode
    POWER_OFF = 5;                // Power off
}

// ===========================
// CORE HARDWARE STRUCTURES
// ===========================

/**
 * Hardware platform identification
 */
message HardwareInfo {
    string hardware_id = 1;        // Unique hardware identifier
    HardwarePlatform platform = 2; // Hardware platform
    string cpu_architecture = 3;   // CPU architecture (arm64, x86_64, etc.)
    string cpu_model = 4;          // CPU model name
    uint32 cpu_cores = 5;          // Number of CPU cores
    uint64 memory_total = 6;       // Total memory in bytes
    string board_model = 7;        // Board model (Pi 4, Pi 5, etc.)
    string board_revision = 8;     // Board revision
    repeated string capabilities = 9; // Hardware capabilities
    map<string, string> properties = 10; // Additional properties
}

/**
 * GPIO pin configuration
 */
message GPIOPin {
    uint32 pin_number = 1;         // Physical pin number
    string pin_name = 2;           // Pin name/label
    GPIOMode mode = 3;             // Pin mode
    GPIOValue value = 4;           // Current pin value
    bool pullup_enabled = 5;       // Pull-up resistor enabled
    bool pulldown_enabled = 6;     // Pull-down resistor enabled
    uint32 pwm_frequency = 7;      // PWM frequency (if PWM mode)
    float pwm_duty_cycle = 8;      // PWM duty cycle (0.0-5.0 senary)
    map<string, string> attributes = 9; // Additional pin attributes
}

/**
 * GPIO bank/controller
 */
message GPIOController {
    string controller_id = 1;      // Controller identifier
    string controller_name = 2;    // Controller name
    repeated GPIOPin pins = 3;     // Available pins
    uint32 pin_count = 4;          // Total number of pins
    repeated GPIOMode supported_modes = 5; // Supported pin modes
    float voltage_level = 6;       // Operating voltage level
    map<string, string> features = 7; // Controller features
}

/**
 * Sensor reading
 */
message SensorReading {
    string sensor_id = 1;          // Sensor identifier
    SensorType type = 2;           // Sensor type
    float value = 3;               // Primary sensor value
    string unit = 4;               // Value unit
    float accuracy = 5;            // Reading accuracy
    float precision = 6;           // Reading precision
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 7;
    map<string, float> additional_values = 8; // Additional sensor values
}

/**
 * Sensor device
 */
message SensorDevice {
    string device_id = 1;          // Device identifier
    string device_name = 2;        // Device name
    SensorType type = 3;           // Sensor type
    string manufacturer = 4;       // Manufacturer
    string model = 5;              // Device model
    CommProtocol protocol = 6;     // Communication protocol
    uint32 address = 7;            // Device address (I2C, SPI, etc.)
    float min_value = 8;           // Minimum measurable value
    float max_value = 9;           // Maximum measurable value
    float resolution = 10;         // Measurement resolution
    uint32 sampling_rate = 11;     // Maximum sampling rate
    PowerState power_state = 12;   // Current power state
    map<string, string> configuration = 13; // Device configuration
}

// ===========================
// COMMUNICATION INTERFACES
// ===========================

/**
 * SPI configuration
 */
message SPIConfig {
    uint32 bus_number = 1;         // SPI bus number
    uint32 device_number = 2;      // SPI device number
    uint32 speed_hz = 3;           // SPI speed in Hz
    uint32 mode = 4;               // SPI mode (0-3)
    uint32 bits_per_word = 5;      // Bits per word
    bool lsb_first = 6;            // LSB first flag
    map<string, string> options = 7; // Additional SPI options
}

/**
 * I2C configuration
 */
message I2CConfig {
    uint32 bus_number = 1;         // I2C bus number
    uint32 device_address = 2;     // Device address
    uint32 speed_hz = 3;           // I2C speed in Hz
    bool ten_bit_address = 4;      // 10-bit addressing
    uint32 timeout_ms = 5;         // Communication timeout
    map<string, string> options = 6; // Additional I2C options
}

/**
 * UART configuration
 */
message UARTConfig {
    string device_path = 1;        // UART device path
    uint32 baud_rate = 2;          // Baud rate
    uint32 data_bits = 3;          // Data bits (5-8)
    uint32 stop_bits = 4;          // Stop bits (1-2)
    string parity = 5;             // Parity (none, even, odd)
    bool flow_control = 6;         // Hardware flow control
    uint32 timeout_ms = 7;         // Read/write timeout
    map<string, string> options = 8; // Additional UART options
}

/**
 * Communication transaction
 */
message CommTransaction {
    string transaction_id = 1;     // Transaction identifier
    CommProtocol protocol = 2;     // Communication protocol
    bytes write_data = 3;          // Data to write
    uint32 read_length = 4;        // Number of bytes to read
    bytes read_data = 5;           // Data read
    bool success = 6;              // Transaction success
    string error_message = 7;      // Error message (if failed)
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 8;
}

// ===========================
// POWER MANAGEMENT
// ===========================

/**
 * Power management configuration
 */
message PowerConfig {
    string power_id = 1;           // Power domain identifier
    PowerState target_state = 2;   // Target power state
    uint32 voltage_mv = 3;         // Target voltage in millivolts
    uint32 frequency_hz = 4;       // Target frequency in Hz
    bool dynamic_scaling = 5;      // Dynamic voltage/frequency scaling
    uint32 sleep_timeout_ms = 6;   // Sleep timeout
    map<string, string> policies = 7; // Power management policies
}

/**
 * Power status
 */
message PowerStatus {
    string power_id = 1;           // Power domain identifier
    PowerState current_state = 2;  // Current power state
    uint32 voltage_mv = 3;         // Current voltage in millivolts
    uint32 frequency_hz = 4;       // Current frequency in Hz
    float current_ma = 5;          // Current consumption in milliamps
    float power_mw = 6;            // Power consumption in milliwatts
    float temperature_c = 7;       // Temperature in Celsius
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 8;
}

/**
 * Energy monitoring
 */
message EnergyMetrics {
    string metrics_id = 1;         // Metrics identifier
    float total_energy_wh = 2;     // Total energy consumed (Watt-hours)
    float average_power_mw = 3;    // Average power consumption
    float peak_power_mw = 4;       // Peak power consumption
    float efficiency_percent = 5;  // Energy efficiency percentage
    uint64 uptime_seconds = 6;     // System uptime
    map<string, float> component_power = 7; // Per-component power usage
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 8;
}

// ===========================
// DEVICE DISCOVERY
// ===========================

/**
 * Hardware capability
 */
message HardwareCapability {
    string capability_id = 1;      // Capability identifier
    string capability_name = 2;    // Capability name
    string description = 3;        // Capability description
    repeated string requirements = 4; // Hardware requirements
    map<string, string> parameters = 5; // Capability parameters
    bool available = 6;            // Capability available
    float confidence = 7;          // Availability confidence (0.0-1.0)
}

/**
 * Device discovery request
 */
message DiscoveryRequest {
    string request_id = 1;         // Request identifier
    repeated CommProtocol protocols = 2; // Protocols to scan
    repeated SensorType sensor_types = 3; // Sensor types to look for
    uint32 timeout_ms = 4;         // Discovery timeout
    bool deep_scan = 5;            // Perform deep scan
    map<string, string> filters = 6; // Discovery filters
}

/**
 * Device discovery result
 */
message DiscoveryResult {
    string request_id = 1;         // Request identifier
    repeated SensorDevice devices = 2; // Discovered devices
    repeated GPIOController gpio_controllers = 3; // GPIO controllers
    repeated HardwareCapability capabilities = 4; // Available capabilities
    uint32 scan_time_ms = 5;       // Time taken for discovery
    bool complete = 6;             // Discovery complete
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 7;
}

// ===========================
// HARDWARE PROTOCOLS
// ===========================

/**
 * Hardware initialization request
 */
message HardwareInitRequest {
    string system_id = 1;          // System identifier
    HardwarePlatform platform = 2; // Target platform (if known)
    repeated string required_capabilities = 3; // Required capabilities
    PowerConfig power_config = 4;  // Power configuration
    bool auto_detect = 5;          // Auto-detect hardware
    map<string, string> configuration = 6; // System configuration
}

/**
 * Hardware operation request
 */
message HardwareRequest {
    string request_id = 1;         // Request identifier
    string operation = 2;          // Operation type
    string target_device = 3;      // Target device/component
    map<string, string> parameters = 4; // Operation parameters
    bytes payload = 5;             // Operation payload
    uint32 priority = 6;           // Request priority (0-5 senary)
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 7;
}

/**
 * Hardware operation response
 */
message HardwareResponse {
    string request_id = 1;         // Request identifier
    bool success = 2;              // Operation success
    bytes result_data = 3;         // Result data
    string error_message = 4;      // Error message (if failed)
    float execution_time = 5;      // Execution time in seconds
    float energy_used = 6;         // Energy consumed
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 7;
}

/**
 * Hardware system status
 */
message HardwareSystemStatus {
    string system_id = 1;          // System identifier
    HardwareInfo hardware_info = 2; // Hardware information
    repeated SensorDevice sensors = 3; // Connected sensors
    repeated GPIOController gpio_controllers = 4; // GPIO controllers
    PowerStatus power_status = 5;  // Power status
    EnergyMetrics energy_metrics = 6; // Energy metrics
    float cpu_usage = 7;           // CPU usage percentage
    float memory_usage = 8;        // Memory usage percentage
    float temperature = 9;         // System temperature
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 10;
}
