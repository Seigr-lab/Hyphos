syntax = "proto3";

package seigr.energy;

// Energy and Power Management Protocol for Seigr OS
// Biomimetic energy systems inspired by cellular metabolism and ecosystem energy flows

import "seigr_timestamp.proto";
import "common.proto";

// Energy sources inspired by biological and natural systems
enum EnergySourceType {
    ENERGY_SOURCE_UNKNOWN = 0;
    
    // Traditional electrical sources
    GRID_POWER = 1;                    // Standard electrical grid
    BATTERY = 2;                       // Chemical battery storage
    UPS = 3;                           // Uninterruptible power supply
    
    // Renewable sources (inspired by photosynthesis and natural cycles)
    SOLAR = 10;                        // Photovoltaic energy harvesting
    WIND = 11;                         // Wind energy harvesting
    HYDROELECTRIC = 12;                // Water flow energy
    GEOTHERMAL = 13;                   // Earth's thermal energy
    TIDAL = 14;                        // Ocean tide energy
    
    // Advanced biological-inspired sources
    KINETIC_HARVESTING = 20;           // Movement energy capture
    THERMAL_GRADIENT = 21;             // Temperature difference energy
    ELECTROMAGNETIC_FIELD = 22;        // EM field energy harvesting
    VIBRATION_ENERGY = 23;             // Vibration to electricity
    BIOCHEMICAL = 24;                  // Bio-chemical energy conversion
    
    // Quantum and advanced sources
    QUANTUM_VACUUM = 30;               // Zero-point energy (theoretical)
    FUSION_CELL = 31;                  // Micro-fusion energy
    ANTIMATTER = 32;                   // Antimatter annihilation
    CONSCIOUSNESS_FIELD = 33;          // Consciousness-energy coupling
    
    // Composite and hybrid sources
    HYBRID_RENEWABLE = 40;             // Multiple renewable sources
    ENERGY_MESH_NETWORK = 41;          // Distributed energy sharing
    SYMBIOTIC_ENERGY = 42;             // Energy from symbiotic relationships
}

// Power states inspired by biological metabolic states
enum PowerState {
    POWER_STATE_UNKNOWN = 0;
    
    // Normal operational states
    OPTIMAL = 1;                       // Peak performance, abundant energy
    NORMAL = 2;                        // Standard operational state
    EFFICIENT = 3;                     // Energy-conserving but fully functional
    
    // Conservation states (like biological energy conservation)
    LOW_POWER = 10;                    // Reduced functionality to save energy
    HIBERNATION = 11;                  // Minimal activity, like animal hibernation
    DORMANT = 12;                      // Suspended animation, very low power
    TORPOR = 13;                       // Temporary low-activity state
    
    // Alert states (like biological stress responses)
    EMERGENCY = 20;                    // Critical power shortage
    SURVIVAL = 21;                     // Bare minimum for system survival
    SHUTDOWN_IMMINENT = 22;            // About to lose power completely
    
    // High-performance states
    BOOSTED = 30;                      // Enhanced performance mode
    OVERCLOCKED = 31;                  // Beyond normal performance limits
    TRANSCENDENT = 32;                 // Maximum possible performance
    
    // Harvesting and charging states
    CHARGING = 40;                     // Actively gaining energy
    HARVESTING = 41;                   // Collecting energy from environment
    ENERGY_SHARING = 42;               // Participating in energy mesh
    REGENERATIVE = 43;                 // Self-healing and energy recovery
}

// Energy consumption patterns inspired by biological processes
enum EnergyConsumptionPattern {
    PATTERN_UNKNOWN = 0;
    
    // Biological-inspired patterns
    METABOLIC_STEADY = 1;              // Constant baseline consumption
    CIRCADIAN_RHYTHM = 2;              // Daily cycle variation
    BURST_ACTIVITY = 3;                // High consumption bursts
    GRADUAL_RAMP = 4;                  // Slowly increasing consumption
    EXPONENTIAL_GROWTH = 5;            // Rapidly increasing consumption
    
    // Performance patterns
    LOAD_RESPONSIVE = 10;              // Consumption based on workload
    PREDICTIVE = 11;                   // Anticipating future needs
    ADAPTIVE = 12;                     // Learning from usage patterns
    OPPORTUNISTIC = 13;                // Using energy when abundant
    
    // Conservation patterns
    AGGRESSIVE_SAVINGS = 20;           // Maximum energy conservation
    SMART_SCALING = 21;                // Intelligent performance scaling
    RESOURCE_POOLING = 22;             // Sharing energy resources
    EFFICIENCY_OPTIMIZATION = 23;      // Optimizing for efficiency
    
    // Emergency patterns
    CRISIS_MODE = 30;                  // Emergency conservation
    GRACEFUL_DEGRADATION = 31;         // Gradually reducing functionality
    CRITICAL_ONLY = 32;                // Only critical functions
}

// Energy measurement and monitoring
message EnergyMeasurement {
    string measurement_id = 1;
    string source_component = 2;
    
    // Basic energy metrics
    float voltage = 3;                 // Voltage level (V)
    float current = 4;                 // Current consumption (A)
    float power_consumption = 5;       // Power usage (W)
    float energy_consumed = 6;         // Total energy used (Wh)
    float efficiency = 7;              // Energy efficiency (0.0 to 1.0)
    
    // Advanced metrics
    float power_factor = 8;            // Power quality metric
    float harmonic_distortion = 9;     // Power signal quality
    float temperature = 10;            // Component temperature (Â°C)
    float heat_generation = 11;        // Heat produced (W)
    
    // Temporal characteristics
    seigr.protocol.timestamp.SeigrTimestamp measurement_time = 12;
    uint32 measurement_duration_ms = 13;
    float average_power = 14;          // Average power over period
    float peak_power = 15;             // Maximum power during period
    
    // Environmental context
    float ambient_temperature = 16;    // Environmental temperature
    float humidity = 17;               // Environmental humidity
    float atmospheric_pressure = 18;   // Atmospheric pressure
    
    // Quality metrics
    bool measurement_valid = 19;
    float measurement_accuracy = 20;   // Confidence in measurement
    string measurement_method = 21;    // How measurement was taken
    
    // Senary optimization
    bool senary_optimized = 22;
    float senary_efficiency_gain = 23;
    
    // Metadata
    map<string, float> additional_metrics = 24;
    map<string, string> metadata = 25;
}

// Energy source configuration and status
message EnergySource {
    string source_id = 1;
    string source_name = 2;
    EnergySourceType source_type = 3;
    
    // Capacity and availability
    float nominal_capacity = 4;        // Rated capacity (Wh)
    float available_capacity = 5;      // Current available capacity
    float maximum_output_power = 6;    // Max power output (W)
    float current_output_power = 7;    // Current power output
    
    // State and health
    PowerState current_state = 8;
    float health_score = 9;            // Overall health (0.0 to 1.0)
    float degradation_rate = 10;       // How quickly capacity degrades
    uint64 charge_cycles = 11;         // Number of charge/discharge cycles
    
    // Efficiency characteristics
    float conversion_efficiency = 12;   // Energy conversion efficiency
    float storage_efficiency = 13;     // Energy storage efficiency
    float transmission_losses = 14;    // Energy lost in transmission
    
    // Environmental factors
    map<string, float> environmental_dependencies = 15; // Weather, etc.
    float optimal_temperature_min = 16;
    float optimal_temperature_max = 17;
    
    // Temporal characteristics
    seigr.protocol.timestamp.SeigrTimestamp installation_time = 18;
    seigr.protocol.timestamp.SeigrTimestamp last_maintenance = 19;
    uint64 total_energy_produced = 20;
    uint64 total_operating_hours = 21;
    
    // Smart features
    bool predictive_available = 22;    // Can predict future availability
    bool load_balancing_capable = 23;  // Can participate in load balancing
    bool grid_interactive = 24;        // Can interact with power grid
    bool energy_sharing_enabled = 25;  // Can share energy with other sources
    
    // Sustainability metrics
    float carbon_footprint = 26;       // CO2 equivalent per kWh
    bool renewable = 27;               // Is this a renewable source?
    float sustainability_score = 28;   // Overall sustainability rating
    
    // Senary optimization
    bool senary_optimized = 29;
    float senary_energy_gain = 30;
    
    // Control and monitoring
    bool remote_controllable = 31;
    repeated string monitoring_sensors = 32;
    map<string, string> control_parameters = 33;
    
    // Metadata
    map<string, string> metadata = 34;
}

// Energy consumer (process, component, or subsystem)
message EnergyConsumer {
    string consumer_id = 1;
    string consumer_name = 2;
    string consumer_type = 3;          // "process", "hardware", "subsystem"
    
    // Current consumption
    float current_power_usage = 4;     // Current power consumption (W)
    EnergyConsumptionPattern consumption_pattern = 5;
    PowerState required_power_state = 6;
    
    // Historical consumption
    float average_power_usage = 7;     // Historical average (W)
    float peak_power_usage = 8;        // Historical peak (W)
    float minimum_power_usage = 9;     // Minimum viable power (W)
    uint64 total_energy_consumed = 10; // Lifetime energy consumption (Wh)
    
    // Performance characteristics
    float performance_per_watt = 11;   // Performance efficiency
    float idle_power_consumption = 12; // Power when not active
    float maximum_power_limit = 13;    // Maximum allowed power
    
    // Power management capabilities
    repeated PowerState supported_power_states = 14;
    bool dynamic_scaling_supported = 15;
    bool hibernation_capable = 16;
    bool energy_harvesting_capable = 17;
    
    // Priority and criticality
    float power_priority = 18;         // Priority for power allocation (0-1)
    bool essential_for_system = 19;    // Critical for system operation
    bool deferrable_workload = 20;     // Can work be deferred to save energy?
    
    // Optimization characteristics
    bool senary_optimized = 21;
    float senary_efficiency_factor = 22;
    repeated string optimization_strategies = 23;
    
    // Quality of service requirements
    float minimum_performance_level = 24;
    uint32 maximum_latency_ms = 25;
    bool real_time_requirements = 26;
    
    // Temporal patterns
    repeated string active_time_periods = 27; // When is this consumer active?
    bool follows_circadian_rhythm = 28;
    map<string, float> usage_patterns = 29;
    
    // Relationship to other consumers
    repeated string dependent_consumers = 30;   // Consumers that depend on this one
    repeated string symbiotic_consumers = 31;   // Consumers that work well together
    repeated string competing_consumers = 32;   // Consumers competing for power
    
    // Environmental adaptation
    float temperature_sensitivity = 33;
    map<string, float> environmental_factors = 34;
    
    // Metadata
    seigr.protocol.timestamp.SeigrTimestamp registration_time = 35;
    seigr.protocol.timestamp.SeigrTimestamp last_activity = 36;
    map<string, string> metadata = 37;
}

// Energy policy and management rules
message EnergyPolicy {
    string policy_id = 1;
    string policy_name = 2;
    string policy_description = 3;
    
    // Policy scope
    repeated string applicable_consumers = 4;
    repeated string applicable_sources = 5;
    repeated string applicable_systems = 6;
    
    // Power state management
    PowerState default_power_state = 7;
    PowerState emergency_power_state = 8;
    map<string, PowerState> conditional_power_states = 9;
    
    // Energy allocation rules
    map<string, float> consumer_priority_weights = 10;
    float reserve_energy_percentage = 11;      // % of capacity to keep in reserve
    bool load_balancing_enabled = 12;
    
    // Conservation triggers
    float low_energy_threshold = 13;           // Trigger conservation at this level
    float critical_energy_threshold = 14;     // Emergency mode threshold
    float optimal_energy_level = 15;          // Target energy level
    
    // Efficiency requirements
    float minimum_efficiency_requirement = 16;
    bool aggressive_optimization_enabled = 17;
    repeated string required_optimizations = 18;
    
    // Time-based rules
    map<string, string> time_based_policies = 19; // Different policies for different times
    bool circadian_optimization = 20;
    repeated string peak_usage_periods = 21;
    
    // Environmental policies
    bool renewable_energy_preferred = 22;
    float maximum_carbon_footprint = 23;
    bool grid_independence_mode = 24;
    
    // Emergency procedures
    repeated string emergency_actions = 25;
    string graceful_shutdown_procedure = 26;
    uint32 emergency_response_time_ms = 27;
    
    // Senary optimization requirements
    bool senary_optimization_mandatory = 28;
    float senary_efficiency_target = 29;
    
    // Policy enforcement
    bool policy_enforcement_strict = 30;
    repeated string enforcement_actions = 31;
    float compliance_tolerance = 32;
    
    // Adaptation and learning
    bool adaptive_policy_enabled = 33;
    float learning_rate = 34;
    repeated string optimization_history = 35;
    
    // Metadata
    seigr.protocol.timestamp.SeigrTimestamp policy_created = 36;
    seigr.protocol.timestamp.SeigrTimestamp last_updated = 37;
    string policy_version = 38;
    map<string, string> metadata = 39;
}

// Energy system status and health
message EnergySystemStatus {
    string system_id = 1;
    
    // Overall system state
    PowerState system_power_state = 2;
    float system_health_score = 3;     // Overall system health (0.0 to 1.0)
    float energy_efficiency = 4;       // System-wide efficiency
    
    // Energy balance
    float total_energy_available = 5;  // Total available energy (Wh)
    float total_energy_consumed = 6;   // Total current consumption (W)
    float energy_reserve_level = 7;    // Energy reserves (Wh)
    float predicted_runtime_hours = 8; // How long system can run
    
    // Source and consumer summary
    repeated EnergySource active_sources = 9;
    repeated EnergyConsumer active_consumers = 10;
    uint32 total_sources = 11;
    uint32 total_consumers = 12;
    
    // Performance metrics
    float system_performance_level = 13; // Current performance (0.0 to 1.0)
    float optimal_performance_level = 14; // Achievable performance
    float energy_cost_per_operation = 15; // Energy per unit of work
    
    // Environmental context
    float ambient_temperature = 16;
    map<string, float> environmental_conditions = 17;
    
    // Trends and predictions
    float energy_trend = 18;           // Increasing/decreasing consumption
    repeated float consumption_forecast = 19; // Predicted future consumption
    repeated float availability_forecast = 20; // Predicted future availability
    
    // Optimization status
    bool senary_optimization_active = 21;
    float optimization_effectiveness = 22;
    repeated string active_optimizations = 23;
    
    // Alerts and issues
    repeated string active_alerts = 24;
    repeated string recommended_actions = 25;
    float criticality_level = 26;      // How critical is current situation
    
    // Sustainability metrics
    float carbon_footprint_current = 27;
    float renewable_energy_percentage = 28;
    float sustainability_score = 29;
    
    // Metadata
    seigr.protocol.timestamp.SeigrTimestamp status_time = 30;
    map<string, string> metadata = 31;
}

// Energy management request
message EnergyRequest {
    string session_id = 1;
    string requesting_component = 2;
    
    // Request type
    enum EnergyOperation {
        OPERATION_UNKNOWN = 0;
        ALLOCATE_POWER = 1;            // Request power allocation
        CHANGE_POWER_STATE = 2;        // Request power state change
        REGISTER_CONSUMER = 3;         // Register new energy consumer
        REGISTER_SOURCE = 4;           // Register new energy source
        UPDATE_POLICY = 5;             // Update energy policy
        OPTIMIZE_SYSTEM = 6;           // Request system optimization
        EMERGENCY_CONSERVATION = 7;    // Emergency power conservation
        HIBERNATE_COMPONENT = 8;       // Put component in hibernation
        WAKE_COMPONENT = 9;            // Wake component from hibernation
        ENERGY_SHARING = 10;           // Participate in energy sharing
        PREDICTIVE_SCALING = 11;       // Request predictive power scaling
    }
    EnergyOperation operation = 3;
    
    // Power requirements
    float requested_power = 4;         // Requested power allocation (W)
    PowerState requested_state = 5;    // Requested power state
    uint32 duration_requested_ms = 6;  // How long power is needed
    float priority_level = 7;          // Request priority (0.0 to 1.0)
    
    // Justification and context
    string purpose = 8;                // Why power is needed
    float business_value = 9;          // Value to system/user
    bool essential_operation = 10;     // Is this critical?
    
    // Flexibility parameters
    float power_flexibility = 11;      // Can accept less power? (0.0 to 1.0)
    uint32 deadline_ms = 12;           // When must this complete?
    bool deferrable = 13;              // Can this be delayed?
    
    // Optimization preferences
    bool prefer_renewable = 14;        // Prefer renewable energy sources
    bool senary_optimization_required = 15;
    float efficiency_target = 16;      // Target efficiency level
    
    // Consumer/source data
    EnergyConsumer consumer_info = 17;
    EnergySource source_info = 18;
    EnergyPolicy policy_data = 19;
    
    // Security and authorization
    string authorization_token = 20;
    seigr.common.ThreatLevel security_level = 21;
    bool authenticated = 22;
}

// Response to energy management requests
message EnergyResponse {
    string session_id = 1;
    bool success = 2;
    string error_message = 3;
    
    // Allocation results
    float allocated_power = 4;         // Actually allocated power (W)
    PowerState granted_state = 5;      // Granted power state
    uint32 allocation_duration_ms = 6; // How long allocation is valid
    
    // System impact
    EnergySystemStatus system_status = 7;
    float system_impact = 8;           // Impact on overall system
    repeated string affected_consumers = 9;
    
    // Optimization results
    float efficiency_achieved = 10;
    float energy_saved = 11;
    repeated string optimizations_applied = 12;
    bool senary_optimized = 13;
    
    // Recommendations
    repeated string recommendations = 14;
    string suggested_power_state = 15;
    repeated string efficiency_suggestions = 16;
    
    // Future predictions
    float predicted_efficiency = 17;
    uint32 estimated_runtime_ms = 18;
    repeated string future_constraints = 19;
    
    // Performance metrics
    uint32 response_time_ms = 20;
    float processing_energy_cost = 21;
    
    // Sustainability impact
    float carbon_footprint_impact = 22;
    float sustainability_score = 23;
    
    // Metadata
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 24;
    map<string, string> metadata = 25;
}

// Service definitions for energy management
service EnergyService {
    // Power allocation and management
    rpc AllocatePower(EnergyRequest) returns (EnergyResponse);
    rpc ChangePowerState(EnergyRequest) returns (EnergyResponse);
    rpc OptimizePowerUsage(EnergyRequest) returns (EnergyResponse);
    
    // Consumer and source management
    rpc RegisterEnergyConsumer(EnergyRequest) returns (EnergyResponse);
    rpc RegisterEnergySource(EnergyRequest) returns (EnergyResponse);
    rpc UpdateEnergyPolicy(EnergyRequest) returns (EnergyResponse);
    
    // System monitoring and control
    rpc GetSystemStatus(EnergyRequest) returns (EnergyResponse);
    rpc MonitorEnergySystem(EnergyRequest) returns (stream EnergyResponse);
    rpc GetEnergyForecast(EnergyRequest) returns (EnergyResponse);
    
    // Power state management
    rpc HibernateComponent(EnergyRequest) returns (EnergyResponse);
    rpc WakeComponent(EnergyRequest) returns (EnergyResponse);
    rpc EmergencyConservation(EnergyRequest) returns (EnergyResponse);
    
    // Optimization and efficiency
    rpc OptimizeForSenary(EnergyRequest) returns (EnergyResponse);
    rpc AnalyzeEnergyEfficiency(EnergyRequest) returns (EnergyResponse);
    rpc PredictivePowerScaling(EnergyRequest) returns (EnergyResponse);
    
    // Sustainability and environmental
    rpc CalculateCarbonFootprint(EnergyRequest) returns (EnergyResponse);
    rpc OptimizeForSustainability(EnergyRequest) returns (EnergyResponse);
    rpc GetRenewableEnergyStatus(EnergyRequest) returns (EnergyResponse);
}
