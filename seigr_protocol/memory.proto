syntax = "proto3";

package seigr.memory;

// Memory Management Protocol for Seigr OS
// Biomimetic memory inspired by neural networks and cellular memory systems

import "seigr_timestamp.proto";
import "common.proto";

// Memory types inspired by biological and computational memory systems
enum MemoryType {
    MEMORY_TYPE_UNKNOWN = 0;
    
    // Biological-inspired memory types
    SENSORY_MEMORY = 1;                // Short-term sensory buffer
    WORKING_MEMORY = 2;                // Active processing memory
    SHORT_TERM_MEMORY = 3;             // Temporary information storage
    LONG_TERM_MEMORY = 4;              // Persistent information storage
    PROCEDURAL_MEMORY = 5;             // Skill and habit memory
    EPISODIC_MEMORY = 6;               // Event and experience memory
    SEMANTIC_MEMORY = 7;               // Knowledge and fact memory
    
    // Computational memory types
    CACHE_MEMORY = 10;                 // High-speed cache
    BUFFER_MEMORY = 11;                // I/O buffering
    STACK_MEMORY = 12;                 // Function call stack
    HEAP_MEMORY = 13;                  // Dynamic allocation
    SHARED_MEMORY = 14;                // Inter-process shared memory
    PERSISTENT_MEMORY = 15;            // Non-volatile storage
    
    // Advanced memory types
    DISTRIBUTED_MEMORY = 20;           // Memory across multiple nodes
    HOLOGRAPHIC_MEMORY = 21;           // Holographic information storage
    QUANTUM_MEMORY = 22;               // Quantum state storage
    CONSCIOUSNESS_MEMORY = 23;         // Awareness and consciousness data
    COLLECTIVE_MEMORY = 24;            // Shared group memory
    GENETIC_MEMORY = 25;               // Inherited information patterns
    
    // Specialized memory
    CRYPTOGRAPHIC_MEMORY = 30;         // Encrypted memory storage
    COMPRESSED_MEMORY = 31;            // Compressed memory regions
    ENERGY_OPTIMIZED_MEMORY = 32;      // Low-power memory
    SENARY_MEMORY = 33;                // Base-6 optimized memory
}

// Memory access patterns inspired by biological behavior
enum MemoryAccessPattern {
    ACCESS_PATTERN_UNKNOWN = 0;
    
    // Sequential patterns
    SEQUENTIAL_FORWARD = 1;            // Linear forward access
    SEQUENTIAL_BACKWARD = 2;           // Linear backward access
    STREAMING = 3;                     // Continuous data flow
    
    // Random patterns
    RANDOM_ACCESS = 10;                // Random memory access
    SPARSE_ACCESS = 11;                // Occasional random access
    CLUSTERED_ACCESS = 12;             // Access to memory clusters
    
    // Biological patterns
    ASSOCIATIVE_ACCESS = 20;           // Association-based retrieval
    CONTEXTUAL_ACCESS = 21;            // Context-dependent access
    EMOTIONAL_ACCESS = 22;             // Emotion-triggered access
    PATTERN_COMPLETION = 23;           // Completing partial patterns
    
    // Performance patterns
    BURST_ACCESS = 30;                 // High-frequency bursts
    PERIODIC_ACCESS = 31;              // Regular interval access
    ADAPTIVE_ACCESS = 32;              // Learning-based access patterns
    PREDICTIVE_ACCESS = 33;            // Anticipated access patterns
    
    // Energy-aware patterns
    POWER_OPTIMIZED = 40;              // Minimize power consumption
    LATENCY_OPTIMIZED = 41;            // Minimize access latency
    BANDWIDTH_OPTIMIZED = 42;          // Maximize throughput
    SENARY_OPTIMIZED = 43;             // Base-6 optimized access
}

// Memory allocation strategies inspired by biological resource allocation
enum AllocationStrategy {
    ALLOCATION_UNKNOWN = 0;
    
    // Basic strategies
    FIRST_FIT = 1;                     // First available block
    BEST_FIT = 2;                      // Smallest sufficient block
    WORST_FIT = 3;                     // Largest available block
    NEXT_FIT = 4;                      // Next available after last allocation
    
    // Biological-inspired strategies
    SYMBIOTIC_ALLOCATION = 10;         // Mutually beneficial placement
    TERRITORIAL_ALLOCATION = 11;       // Exclusive region allocation
    ADAPTIVE_ALLOCATION = 12;          // Learning-based allocation
    ECOSYSTEM_ALLOCATION = 13;         // Ecosystem-aware placement
    
    // Performance strategies
    LOCALITY_OPTIMIZED = 20;           // Optimize for spatial locality
    TEMPORAL_OPTIMIZED = 21;           // Optimize for temporal locality
    ENERGY_OPTIMIZED = 22;             // Minimize energy usage
    ALLOCATION_LATENCY_OPTIMIZED = 23; // Minimize access latency
    
    // Advanced strategies
    HOLOGRAPHIC_ALLOCATION = 30;       // Distributed holographic storage
    QUANTUM_ALLOCATION = 31;           // Quantum superposition allocation
    CONSCIOUSNESS_AWARE = 32;          // Consciousness-level optimization
    SENARY_ALLOCATION = 33;            // Base-6 aligned allocation
}

// Memory region with biological characteristics
message MemoryRegion {
    string region_id = 1;
    string region_name = 2;
    MemoryType memory_type = 3;
    
    // Physical characteristics
    uint64 base_address = 4;           // Starting address
    uint64 size_bytes = 5;             // Region size
    uint64 used_bytes = 6;             // Currently used
    uint64 available_bytes = 7;        // Available for allocation
    uint32 alignment_bytes = 8;        // Memory alignment requirement
    
    // Access characteristics
    MemoryAccessPattern access_pattern = 9;
    AllocationStrategy allocation_strategy = 10;
    bool read_only = 11;
    bool executable = 12;
    bool cacheable = 13;
    
    // Performance characteristics
    uint32 access_latency_ns = 14;     // Average access latency
    uint64 bandwidth_mbps = 15;        // Memory bandwidth
    float power_consumption_mw = 16;   // Power consumption
    float error_rate = 17;             // Bit error rate
    
    // Biological-inspired properties
    float memory_strength = 18;        // How strongly information is held (0-1)
    float forgetting_rate = 19;        // Rate of information decay
    float association_strength = 20;   // Strength of associative links
    float emotional_weight = 21;       // Emotional significance (-1 to 1)
    
    // Temporal characteristics
    seigr.protocol.timestamp.SeigrTimestamp creation_time = 22;
    seigr.protocol.timestamp.SeigrTimestamp last_access_time = 23;
    uint64 access_count = 24;
    uint32 time_since_last_access_ms = 25;
    
    // Health and reliability
    float health_score = 26;           // Overall health (0-1)
    uint32 error_count = 27;
    uint32 refresh_cycles = 28;        // For dynamic memory
    bool requires_refresh = 29;
    
    // Optimization characteristics
    bool senary_optimized = 30;
    float senary_efficiency = 31;
    bool energy_optimized = 32;
    bool compression_enabled = 33;
    float compression_ratio = 34;
    
    // Security characteristics
    bool encrypted = 35;
    string encryption_algorithm = 36;
    seigr.common.ThreatLevel security_level = 37;
    bool access_controlled = 38;
    
    // Sharing and collaboration
    repeated string authorized_processes = 39;
    bool shareable = 40;
    bool copy_on_write = 41;
    uint32 reference_count = 42;
    
    // Environmental adaptation
    map<string, float> environmental_factors = 43; // Temperature, humidity, etc.
    float temperature_sensitivity = 44;
    bool adaptive_refresh_rate = 45;
    
    // Metadata
    map<string, string> metadata = 46;
}

// Memory allocation request
message MemoryAllocationRequest {
    string allocation_id = 1;
    string requesting_process = 2;
    
    // Allocation requirements
    uint64 size_bytes = 3;
    uint32 alignment_bytes = 4;
    MemoryType preferred_type = 5;
    MemoryAccessPattern expected_pattern = 6;
    AllocationStrategy preferred_strategy = 7;
    
    // Performance requirements
    uint32 max_latency_ns = 8;         // Maximum acceptable latency
    uint64 min_bandwidth_mbps = 9;     // Minimum bandwidth requirement
    float max_power_consumption_mw = 10; // Power budget
    float min_reliability = 11;        // Minimum reliability requirement
    
    // Temporal requirements
    uint32 expected_lifetime_ms = 12;  // How long allocation is needed
    bool persistent_across_reboots = 13;
    uint32 urgency_level = 14;         // How urgently needed (1-6)
    
    // Biological-inspired preferences
    float memory_strength_required = 15; // How strongly to hold information
    float association_capability = 16;   // Need for associative links
    bool emotional_tagging_required = 17; // Need emotional metadata
    bool consciousness_accessible = 18;   // Accessible to consciousness
    
    // Security requirements
    bool encryption_required = 19;
    string encryption_algorithm = 20;
    seigr.common.ThreatLevel security_level = 21;
    repeated string authorized_processes = 22;
    
    // Sharing requirements
    bool shareable = 23;
    bool atomic_operations_required = 24;
    bool copy_on_write_preferred = 25;
    
    // Optimization preferences
    bool senary_optimization_required = 26;
    bool energy_optimization_preferred = 27;
    bool compression_acceptable = 28;
    float performance_priority = 29;    // Performance vs efficiency (0-1)
    
    // Fallback options
    uint64 minimum_acceptable_size = 30;
    repeated MemoryType acceptable_types = 31;
    bool allow_fragmented_allocation = 32;
    bool allow_slower_memory = 33;
    
    // Justification and context
    string purpose = 34;
    float business_value = 35;
    bool essential_for_operation = 36;
    
    // Environmental context
    map<string, float> environmental_conditions = 37;
    bool temperature_stable_required = 38;
    
    // Authorization
    string authorization_token = 39;
    bool authenticated = 40;
}

// Memory allocation response
message MemoryAllocationResponse {
    string allocation_id = 1;
    bool success = 2;
    string error_message = 3;
    
    // Allocation details
    MemoryRegion allocated_region = 4;
    uint64 allocated_address = 5;
    uint64 allocated_size = 6;
    MemoryType allocated_type = 7;
    
    // Performance characteristics
    uint32 actual_latency_ns = 8;
    uint64 actual_bandwidth_mbps = 9;
    float actual_power_consumption_mw = 10;
    float reliability_score = 11;
    
    // Optimization results
    bool senary_optimized = 12;
    float energy_efficiency = 13;
    bool compression_applied = 14;
    float compression_ratio = 15;
    
    // Security implementation
    bool encryption_applied = 16;
    string encryption_algorithm_used = 17;
    bool access_control_applied = 18;
    
    // Alternative allocations (if requested allocation not possible)
    repeated MemoryRegion alternative_regions = 19;
    string allocation_recommendations = 20;
    
    // System impact
    float system_memory_utilization = 21;
    uint32 remaining_free_memory = 22;
    float fragmentation_level = 23;
    
    // Performance predictions
    float predicted_performance = 24;
    uint32 estimated_lifetime_ms = 25;
    repeated string optimization_suggestions = 26;
    
    // Biological metrics
    float memory_strength_achieved = 27;
    float association_capability_level = 28;
    bool consciousness_integration = 29;
    
    // Metadata
    seigr.protocol.timestamp.SeigrTimestamp allocation_time = 30;
    map<string, string> metadata = 31;
}

// Memory usage statistics and patterns
message MemoryUsageStatistics {
    string statistics_id = 1;
    string scope = 2;                  // "system", "process", "region"
    
    // Basic usage statistics
    uint64 total_memory = 3;
    uint64 used_memory = 4;
    uint64 free_memory = 5;
    uint64 cached_memory = 6;
    uint64 buffered_memory = 7;
    float utilization_percentage = 8;
    
    // Allocation statistics
    uint32 active_allocations = 9;
    uint64 total_allocations = 10;
    uint64 failed_allocations = 11;
    float allocation_success_rate = 12;
    uint64 average_allocation_size = 13;
    
    // Performance metrics
    float average_access_latency_ns = 14;
    uint64 memory_bandwidth_utilization = 15;
    uint32 cache_hit_rate_percentage = 16;
    uint32 page_fault_rate = 17;
    
    // Biological-inspired metrics
    float average_memory_strength = 18;
    float forgetting_rate = 19;
    uint32 association_count = 20;
    float emotional_content_level = 21;
    
    // Energy and efficiency
    float total_power_consumption_mw = 22;
    float energy_efficiency_score = 23;
    bool senary_optimization_active = 24;
    float senary_efficiency_gain = 25;
    
    // Temporal patterns
    repeated float hourly_usage_pattern = 26;  // 24 hours
    repeated float daily_usage_pattern = 27;   // 7 days
    seigr.protocol.timestamp.SeigrTimestamp measurement_period_start = 28;
    seigr.protocol.timestamp.SeigrTimestamp measurement_period_end = 29;
    
    // Health and reliability
    uint32 memory_errors = 30;
    float error_rate = 31;
    uint32 corrected_errors = 32;
    uint32 uncorrected_errors = 33;
    float reliability_score = 34;
    
    // Fragmentation analysis
    float external_fragmentation = 35;
    float internal_fragmentation = 36;
    uint32 largest_free_block = 37;
    uint32 free_block_count = 38;
    
    // Access patterns
    map<string, uint64> access_pattern_counts = 39;
    repeated string frequent_access_regions = 40;
    float spatial_locality_score = 41;
    float temporal_locality_score = 42;
    
    // Optimization opportunities
    repeated string optimization_recommendations = 43;
    float potential_energy_savings = 44;
    float potential_performance_gains = 45;
    
    // Security metrics
    uint32 encrypted_regions = 46;
    uint32 access_violations = 47;
    float security_compliance_score = 48;
    
    // Metadata
    map<string, string> metadata = 49;
}

// Memory management configuration
message MemoryConfiguration {
    string config_id = 1;
    string config_name = 2;
    
    // Global memory policies
    AllocationStrategy default_allocation_strategy = 3;
    uint32 default_alignment = 4;
    bool compression_enabled_by_default = 5;
    bool encryption_required_by_default = 6;
    
    // Performance tuning
    uint32 cache_size_kb = 7;
    uint32 buffer_pool_size_mb = 8;
    bool adaptive_caching = 9;
    bool predictive_prefetching = 10;
    
    // Biological-inspired settings
    float default_memory_strength = 11;
    float global_forgetting_rate = 12;
    bool emotional_tagging_enabled = 13;
    bool consciousness_integration_enabled = 14;
    bool associative_memory_enabled = 15;
    
    // Energy management
    bool energy_optimization_enabled = 16;
    float power_budget_mw = 17;
    bool dynamic_power_scaling = 18;
    bool hibernate_unused_regions = 19;
    
    // Senary optimization
    bool senary_optimization_enabled = 20;
    bool senary_addressing = 21;
    bool senary_alignment_preferred = 22;
    
    // Security settings
    string default_encryption_algorithm = 23;
    bool memory_protection_enabled = 24;
    bool access_logging_enabled = 25;
    seigr.common.ThreatLevel default_security_level = 26;
    
    // Garbage collection and cleanup
    bool automatic_garbage_collection = 27;
    uint32 garbage_collection_interval_ms = 28;
    float memory_pressure_threshold = 29;
    bool defragmentation_enabled = 30;
    
    // Environmental adaptation
    bool temperature_adaptive = 31;
    float temperature_threshold_celsius = 32;
    bool humidity_compensation = 33;
    
    // Monitoring and logging
    bool usage_statistics_enabled = 34;
    uint32 statistics_collection_interval_ms = 35;
    bool performance_monitoring_enabled = 36;
    
    // Limits and quotas
    map<string, uint64> process_memory_limits = 37;
    uint64 system_memory_reserve = 38;
    uint32 max_allocations_per_process = 39;
    
    // Metadata
    seigr.protocol.timestamp.SeigrTimestamp config_version_time = 40;
    map<string, string> metadata = 41;
}

// Memory management request
message MemoryRequest {
    string session_id = 1;
    string requesting_component = 2;
    
    // Request type
    enum MemoryOperation {
        OPERATION_UNKNOWN = 0;
        ALLOCATE_MEMORY = 1;           // Allocate new memory region
        DEALLOCATE_MEMORY = 2;         // Free memory region
        REALLOCATE_MEMORY = 3;         // Resize existing allocation
        QUERY_MEMORY_STATUS = 4;       // Get memory status
        DEFRAGMENT_MEMORY = 5;         // Defragment memory
        GARBAGE_COLLECT = 6;           // Run garbage collection
        OPTIMIZE_MEMORY = 7;           // Optimize memory usage
        BACKUP_MEMORY = 8;             // Backup memory contents
        RESTORE_MEMORY = 9;            // Restore memory contents
        ENCRYPT_REGION = 10;           // Encrypt memory region
        COMPRESS_REGION = 11;          // Compress memory region
        ASSOCIATE_MEMORIES = 12;       // Create memory associations
        STRENGTHEN_MEMORY = 13;        // Increase memory strength
        WEAKEN_MEMORY = 14;            // Decrease memory strength
        TRANSFER_MEMORY = 15;          // Transfer between regions
    }
    MemoryOperation operation = 3;
    
    // Request data
    MemoryAllocationRequest allocation_request = 4;
    MemoryConfiguration configuration = 5;
    repeated string target_region_ids = 6;
    
    // Operation parameters
    map<string, string> parameters = 7;
    float intensity = 8;               // Operation intensity (0-1)
    uint32 timeout_ms = 9;
    bool force_operation = 10;
    
    // Optimization preferences
    bool senary_optimization_preferred = 11;
    bool energy_optimization_preferred = 12;
    float performance_priority = 13;    // Performance vs efficiency
    
    // Security and authorization
    string authorization_token = 14;
    seigr.common.ThreatLevel security_level = 15;
    bool authenticated = 16;
}

// Memory management response
message MemoryResponse {
    string session_id = 1;
    bool success = 2;
    string error_message = 3;
    
    // Response data
    MemoryAllocationResponse allocation_response = 4;
    MemoryUsageStatistics usage_statistics = 5;
    repeated MemoryRegion memory_regions = 6;
    
    // Operation results
    uint32 operation_time_ms = 7;
    float energy_consumed_mw = 8;
    float efficiency_achieved = 9;
    bool senary_optimized = 10;
    
    // System state
    float system_memory_health = 11;
    float fragmentation_level = 12;
    uint32 available_memory_mb = 13;
    
    // Performance impact
    float performance_impact = 14;
    repeated string affected_processes = 15;
    string performance_recommendations = 16;
    
    // Biological insights
    float memory_coherence_level = 17;
    uint32 new_associations_formed = 18;
    float consciousness_integration_level = 19;
    
    // Optimization results
    repeated string optimizations_applied = 20;
    float optimization_effectiveness = 21;
    string future_optimization_suggestions = 22;
    
    // Metadata
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 23;
    map<string, string> metadata = 24;
}

// Service definitions for memory management
service MemoryService {
    // Basic memory operations
    rpc AllocateMemory(MemoryRequest) returns (MemoryResponse);
    rpc DeallocateMemory(MemoryRequest) returns (MemoryResponse);
    rpc ReallocateMemory(MemoryRequest) returns (MemoryResponse);
    
    // Memory status and monitoring
    rpc GetMemoryStatus(MemoryRequest) returns (MemoryResponse);
    rpc GetUsageStatistics(MemoryRequest) returns (MemoryResponse);
    rpc MonitorMemorySystem(MemoryRequest) returns (stream MemoryResponse);
    
    // Memory optimization
    rpc OptimizeMemory(MemoryRequest) returns (MemoryResponse);
    rpc DefragmentMemory(MemoryRequest) returns (MemoryResponse);
    rpc GarbageCollect(MemoryRequest) returns (MemoryResponse);
    
    // Advanced memory operations
    rpc CompressMemoryRegion(MemoryRequest) returns (MemoryResponse);
    rpc EncryptMemoryRegion(MemoryRequest) returns (MemoryResponse);
    rpc TransferMemory(MemoryRequest) returns (MemoryResponse);
    
    // Biological-inspired operations
    rpc AssociateMemories(MemoryRequest) returns (MemoryResponse);
    rpc StrengthenMemory(MemoryRequest) returns (MemoryResponse);
    rpc WeakenMemory(MemoryRequest) returns (MemoryResponse);
    
    // Configuration and policy
    rpc UpdateConfiguration(MemoryRequest) returns (MemoryResponse);
    rpc GetConfiguration(MemoryRequest) returns (MemoryResponse);
    
    // Senary optimization
    rpc OptimizeForSenary(MemoryRequest) returns (MemoryResponse);
    rpc CalculateMemoryEfficiency(MemoryRequest) returns (MemoryResponse);
}
