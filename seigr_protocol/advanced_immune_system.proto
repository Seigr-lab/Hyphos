syntax = "proto3";

package seigr.immune_system;

import "seigr_timestamp.proto";
import "common.proto";

/**
 * Advanced Immune System Protocol
 *
 * Enhanced protocol definitions for the Seigr Immune System, focusing on 
 * sophisticated anomaly detection, adaptive self-healing, and emergent 
 * immune response capabilities.
 */

// ===========================
// ENUMS
// ===========================

/**
 * Types of anomalies that can be detected in the Seigr ecosystem
 */
enum AnomalyType {
  ANOMALY_TYPE_UNSPECIFIED = 0;
  ANOMALY_TYPE_USAGE_PATTERN = 1;      // Unusual usage patterns
  ANOMALY_TYPE_RESOURCE_CONSUMPTION = 2; // Abnormal resource consumption
  ANOMALY_TYPE_ACCESS_PATTERN = 3;     // Unusual access patterns
  ANOMALY_TYPE_INTEGRITY_BREACH = 4;   // Data integrity issues
  ANOMALY_TYPE_NETWORK_BEHAVIOR = 5;   // Network communication anomalies
  ANOMALY_TYPE_PROTOCOL_VIOLATION = 6; // Protocol compliance violations
  ANOMALY_TYPE_TEMPORAL = 7;           // Time-based anomalies
  ANOMALY_TYPE_STRUCTURAL = 8;         // Structure/pattern anomalies
  ANOMALY_TYPE_CRYPTOGRAPHIC = 9;      // Cryptographic verification failures
  ANOMALY_TYPE_BEHAVIORAL = 10;        // AI-detected behavioral anomalies
}

/**
 * Algorithms that can be used for anomaly detection
 */
enum AnomalyDetectionAlgorithm {
  ALGORITHM_UNSPECIFIED = 0;
  ALGORITHM_STATISTICAL = 1;           // Statistical methods (z-score, etc.)
  ALGORITHM_ISOLATION_FOREST = 2;      // Isolation forest algorithm
  ALGORITHM_AUTOENCODER = 3;           // Neural network autoencoders
  ALGORITHM_DENSITY_BASED = 4;         // DBSCAN and similar algorithms
  ALGORITHM_ONE_CLASS_SVM = 5;         // One-class SVM
  ALGORITHM_BAYESIAN = 6;              // Bayesian anomaly detection
  ALGORITHM_MARKOV_CHAIN = 7;          // Markov chain-based detection
  ALGORITHM_WAVELET_TRANSFORM = 8;     // Wavelet analysis
  ALGORITHM_ENSEMBLE = 9;              // Ensemble of multiple algorithms
  ALGORITHM_GRAPH_BASED = 10;          // Graph-based anomaly detection
}

/**
 * Self-healing strategies available for segment recovery
 */
enum HealingStrategy {
  STRATEGY_UNSPECIFIED = 0;
  STRATEGY_ROLLBACK = 1;               // Rollback to previous state
  STRATEGY_REPLICATION = 2;            // Use replicated segments
  STRATEGY_RECONSTRUCTION = 3;         // Reconstruct from available data
  STRATEGY_PARTIAL_RECOVERY = 4;       // Recover only critical portions
  STRATEGY_QUARANTINE = 5;             // Isolate and contain damage
  STRATEGY_PROTOCOL_RENEGOTIATION = 6; // Renegotiate protocol compliance
  STRATEGY_DYNAMIC_RECONFIGURATION = 7; // Reconfigure system parameters
  STRATEGY_CRYPTOGRAPHIC_REFRESH = 8;  // Refresh cryptographic material
  STRATEGY_DISTRIBUTED_CONSENSUS = 9;  // Use consensus to determine state
  STRATEGY_AI_GUIDED_REPAIR = 10;      // AI-driven repair process
}

// ===========================
// MESSAGES
// ===========================

/**
 * Enhanced request for advanced anomaly detection
 */
message EnhancedAnomalyDetectionRequest {
  string segment_hash = 1;                // Target segment hash
  repeated AnomalyType types_to_check = 2; // Types of anomalies to check for
  repeated AnomalyDetectionAlgorithm algorithms = 3; // Algorithms to use
  map<string, float> detection_parameters = 4; // Algorithm parameters
  bool include_historical_context = 5;   // Whether to include historical data
  int32 lookback_period = 6;             // How far back to look (time units)
  string detection_context = 7;          // Additional context for detection
  seigr.protocol.timestamp.SeigrTimestamp timestamp = 8; // When the request was made
  repeated string related_segment_hashes = 9; // Related segments for contextual analysis
  map<string, string> metadata = 10;     // Additional metadata
}

/**
 * Detailed information about a detected anomaly
 */
message AnomalyDetails {
  string anomaly_id = 1;                 // Unique identifier
  AnomalyType type = 2;                  // Type of anomaly
  float confidence_score = 3;            // Confidence in detection (0.0-1.0)
  float severity_score = 4;              // Severity of anomaly (0.0-1.0)
  seigr.protocol.timestamp.SeigrTimestamp detected_at = 5; // When the anomaly was detected
  AnomalyDetectionAlgorithm algorithm_used = 6; // Algorithm that detected it
  map<string, float> anomaly_metrics = 7; // Metrics describing the anomaly
  map<string, string> evidence = 8;      // Evidence supporting detection
  repeated string affected_components = 9; // Components affected
  string description = 10;               // Human-readable description
  seigr.common.ThreatLevel threat_level = 11; // Associated threat level
  map<string, string> metadata = 12;     // Additional metadata
}

/**
 * Enhanced response for advanced anomaly detection
 */
message EnhancedAnomalyDetectionResponse {
  bool success = 1;                     // Success flag
  repeated AnomalyDetails anomalies = 2; // Detailed anomalies detected
  map<string, float> detection_metrics = 3; // Performance metrics of detection
  string detection_summary = 4;         // Summary of findings
  map<string, float> segment_health_score = 5; // Health scores for segment
  repeated string recommended_actions = 6; // Recommended actions
  string lineage_proof = 7;             // Cryptographic proof of lineage
  map<string, string> metadata = 8;     // Additional metadata
}

/**
 * Enhanced request for advanced self-healing
 */
message EnhancedSegmentRecoveryRequest {
  string segment_hash = 1;              // Segment hash for recovery
  repeated HealingStrategy strategies = 2; // Strategies to consider
  map<string, float> strategy_weights = 3; // Weights for each strategy
  int32 recovery_priority = 4;          // Priority of recovery (1-10)
  bool force_healing = 5;               // Whether to force healing
  map<string, string> recovery_parameters = 6; // Parameters for recovery
  seigr.protocol.timestamp.SeigrTimestamp timestamp = 7; // When the request was made
  repeated string related_segment_hashes = 8; // Related segments
  repeated AnomalyDetails triggering_anomalies = 9; // Anomalies that triggered recovery
  map<string, string> metadata = 10;    // Additional metadata
}

/**
 * Detailed information about a healing operation
 */
message HealingOperation {
  string operation_id = 1;              // Unique identifier
  HealingStrategy strategy_used = 2;    // Strategy that was used
  float success_score = 3;              // Success score (0.0-1.0)
  seigr.protocol.timestamp.SeigrTimestamp started_at = 4; // When healing started
  seigr.protocol.timestamp.SeigrTimestamp completed_at = 5; // When healing completed
  map<string, float> operation_metrics = 6; // Metrics of the operation
  string status = 7;                    // Status (success, partial, failed)
  repeated string actions_taken = 8;    // Actions that were taken
  string description = 9;               // Human-readable description
  map<string, string> metadata = 10;    // Additional metadata
}

/**
 * Enhanced response for advanced self-healing
 */
message EnhancedSegmentRecoveryResponse {
  bool success = 1;                     // Overall success flag
  repeated HealingOperation operations = 2; // Healing operations performed
  float segment_health_before = 3;      // Health before healing (0.0-1.0)
  float segment_health_after = 4;       // Health after healing (0.0-1.0)
  string recovery_summary = 5;          // Summary of recovery
  map<string, float> recovery_metrics = 6; // Metrics of recovery process
  repeated string remaining_issues = 7; // Issues that couldn't be resolved
  string lineage_proof = 8;             // Cryptographic proof of lineage
  map<string, string> metadata = 9;     // Additional metadata
}

/**
 * Empty request message for simple operations that don't need parameters
 */
message EmptyRequest {
}

/**
 * Comprehensive immune system health report
 */
message ImmuneSystemHealthReport {
  seigr.protocol.timestamp.SeigrTimestamp timestamp = 1; // When report was generated
  map<string, float> detection_effectiveness = 2; // Effectiveness metrics
  map<string, float> healing_effectiveness = 3; // Healing effectiveness
  int32 active_threats = 4;             // Number of active threats
  int32 resolved_threats = 5;           // Number of resolved threats
  map<string, float> resource_utilization = 6; // Resource usage
  float overall_health_score = 7;       // Overall health (0.0-1.0)
  repeated string active_countermeasures = 8; // Active countermeasures
  map<string, float> adaptation_metrics = 9; // Adaptation metrics
  string report_summary = 10;           // Summary of findings
  string lineage_proof = 11;            // Cryptographic proof of lineage
  map<string, string> metadata = 12;    // Additional metadata
}

// ===========================
// SERVICES
// ===========================

/**
 * Advanced Immune System Service
 */
service AdvancedImmuneSystem {
  // Advanced anomaly detection
  rpc DetectAnomaliesAdvanced (EnhancedAnomalyDetectionRequest) returns (EnhancedAnomalyDetectionResponse);
  
  // Advanced self-healing
  rpc HealSegmentAdvanced (EnhancedSegmentRecoveryRequest) returns (EnhancedSegmentRecoveryResponse);
  
  // Get immune system health report
  rpc GetImmuneSystemHealth (EmptyRequest) returns (ImmuneSystemHealthReport);
}
