syntax = "proto3";

package seigr.audio;

import "seigr_timestamp.proto";
import "common.proto";

/**
 * Seigr Native Audio Protocol (SNAF)
 * 
 * Complete hardware-agnostic audio system using senary-optimized
 * signal processing and energy-aware audio operations. Zero third-party dependencies.
 * 
 * Philosophy:
 * - All audio data in senary (base-6) representation
 * - Energy-conscious audio processing
 * - Hardware abstraction for any audio device
 * - Protocol-driven, emergent audio capabilities
 * - Native conversion from external formats (WAV, MP3, etc.) to SNAF
 */

// ===========================
// ENUMS
// ===========================

/**
 * Senary-optimized audio sample formats
 */
enum SenaryAudioFormat {
    SENARY_PCM_8 = 0;      // 8-bit PCM, senary values (0-5)
    SENARY_PCM_16 = 1;     // 16-bit PCM, senary-optimized
    SENARY_PCM_24 = 2;     // 24-bit PCM, senary-optimized
    SENARY_PCM_32 = 3;     // 32-bit PCM, senary-optimized
    SENARY_FLOAT = 4;      // 32-bit float, senary normalized
    SENARY_COMPRESSED = 5; // Senary-optimized compression
}

/**
 * Audio processing algorithms
 */
enum AudioAlgorithm {
    ALGORITHM_PASSTHROUGH = 0;  // No processing
    ALGORITHM_AMPLIFY = 1;      // Amplitude adjustment
    ALGORITHM_FILTER = 2;       // Frequency filtering
    ALGORITHM_REVERB = 3;       // Reverb effect
    ALGORITHM_ECHO = 4;         // Echo effect
    ALGORITHM_COMPRESS = 5;     // Dynamic range compression
    ALGORITHM_NORMALIZE = 6;    // Audio normalization
    ALGORITHM_SENARY_ENHANCE = 7; // Senary-specific enhancement
}

/**
 * Audio device types
 */
enum AudioDeviceType {
    DEVICE_INPUT = 0;      // Input device (microphone)
    DEVICE_OUTPUT = 1;     // Output device (speakers)
    DEVICE_DUPLEX = 2;     // Input/Output device
    DEVICE_VIRTUAL = 3;    // Virtual audio device
}

/**
 * Audio stream states
 */
enum StreamState {
    STREAM_STOPPED = 0;
    STREAM_PLAYING = 1;
    STREAM_PAUSED = 2;
    STREAM_RECORDING = 3;
    STREAM_BUFFERING = 4;
    STREAM_ERROR = 5;
}

// ===========================
// CORE DATA STRUCTURES
// ===========================

/**
 * Senary-optimized audio sample
 */
message SenaryAudioSample {
    SenaryAudioFormat format = 1;   // Sample format
    uint32 channels = 2;            // Number of channels (1-6, senary)
    uint32 sample_rate = 3;         // Sample rate in Hz
    repeated int32 data = 4;        // Raw sample data (senary values)
    float amplitude = 5;            // Sample amplitude (0.0-5.0)
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 6;
}

/**
 * Audio buffer for efficient processing
 */
message AudioBuffer {
    string buffer_id = 1;           // Unique buffer identifier
    SenaryAudioFormat format = 2;   // Audio format
    uint32 channels = 3;            // Number of channels
    uint32 sample_rate = 4;         // Sample rate
    uint32 frame_count = 5;         // Number of frames
    bytes sample_data = 6;          // Raw audio data
    float duration = 7;             // Buffer duration in seconds
    map<string, string> metadata = 8; // Buffer metadata
}

/**
 * Native Seigr audio track
 */
message SeigrAudioTrack {
    string track_id = 1;            // Unique track identifier
    string title = 2;               // Track title
    SenaryAudioFormat format = 3;   // Audio format
    uint32 channels = 4;            // Number of channels
    uint32 sample_rate = 5;         // Sample rate
    float duration = 6;             // Track duration in seconds
    repeated AudioBuffer buffers = 7; // Audio data buffers
    map<string, string> metadata = 8; // Track metadata
    seigr.protocol.timestamp.SeigrTimestamp created_at = 9;
    float energy_efficiency = 10;   // Energy efficiency rating
}

/**
 * Audio device capabilities
 */
message AudioDeviceCapabilities {
    string device_id = 1;           // Device identifier
    AudioDeviceType type = 2;       // Device type
    repeated SenaryAudioFormat supported_formats = 3; // Supported formats
    repeated uint32 supported_rates = 4; // Supported sample rates
    uint32 max_channels = 5;        // Maximum channels
    uint32 min_buffer_size = 6;     // Minimum buffer size
    uint32 max_buffer_size = 7;     // Maximum buffer size
    float latency = 8;              // Device latency in ms
    float energy_consumption = 9;   // Energy consumption rating
    map<string, string> features = 10; // Device-specific features
}

/**
 * Audio processing chain
 */
message AudioProcessingChain {
    string chain_id = 1;            // Unique chain identifier
    repeated AudioProcessor processors = 2; // Audio processors in order
    SenaryAudioFormat input_format = 3; // Input format
    SenaryAudioFormat output_format = 4; // Output format
    map<string, string> configuration = 5; // Chain configuration
    bool real_time = 6;             // Real-time processing flag
}

/**
 * Individual audio processor
 */
message AudioProcessor {
    string processor_id = 1;        // Unique processor identifier
    AudioAlgorithm algorithm = 2;   // Processing algorithm
    map<string, float> parameters = 3; // Processor parameters
    bool enabled = 4;               // Processor enabled state
    uint32 order = 5;               // Processing order
    float cpu_usage = 6;            // CPU usage percentage
    float energy_cost = 7;          // Energy cost per sample
}

// ===========================
// AUDIO STREAMING
// ===========================

/**
 * Audio stream configuration
 */
message AudioStreamConfig {
    string stream_id = 1;           // Unique stream identifier
    SenaryAudioFormat format = 2;   // Stream format
    uint32 channels = 3;            // Number of channels
    uint32 sample_rate = 4;         // Sample rate
    uint32 buffer_size = 5;         // Buffer size in frames
    uint32 buffer_count = 6;        // Number of buffers
    AudioDeviceCapabilities device = 7; // Target device
    bool real_time = 8;             // Real-time streaming
}

/**
 * Audio stream control
 */
message AudioStreamControl {
    string stream_id = 1;           // Stream identifier
    string command = 2;             // Control command (start, stop, pause)
    map<string, string> parameters = 3; // Command parameters
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 4;
}

/**
 * Audio stream status
 */
message AudioStreamStatus {
    string stream_id = 1;           // Stream identifier
    StreamState state = 2;          // Current stream state
    float position = 3;             // Current position in seconds
    float buffer_level = 4;         // Buffer fill level (0.0-1.0)
    uint32 underruns = 5;           // Number of buffer underruns
    uint32 overruns = 6;            // Number of buffer overruns
    float cpu_usage = 7;            // CPU usage percentage
    float energy_usage = 8;         // Energy usage rate
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 9;
}

// ===========================
// AUDIO ANALYSIS
// ===========================

/**
 * Audio frequency analysis
 */
message FrequencyAnalysis {
    string analysis_id = 1;         // Unique analysis identifier
    repeated float frequencies = 2;  // Frequency bins
    repeated float magnitudes = 3;   // Magnitude values
    float fundamental_freq = 4;      // Fundamental frequency
    repeated float harmonics = 5;    // Harmonic frequencies
    float spectral_centroid = 6;     // Spectral centroid
    float spectral_rolloff = 7;      // Spectral rolloff
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 8;
}

/**
 * Audio envelope analysis
 */
message AudioEnvelope {
    string envelope_id = 1;         // Unique envelope identifier
    float attack = 2;               // Attack time
    float decay = 3;                // Decay time
    float sustain = 4;              // Sustain level
    float release = 5;              // Release time
    float peak_amplitude = 6;       // Peak amplitude
    float rms_amplitude = 7;        // RMS amplitude
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 8;
}

/**
 * Audio feature extraction
 */
message AudioFeatures {
    string feature_id = 1;          // Unique feature identifier
    float tempo = 2;                // Tempo in BPM
    float pitch = 3;                // Average pitch
    float loudness = 4;             // Perceived loudness
    float brightness = 5;           // Spectral brightness
    float roughness = 6;            // Spectral roughness
    FrequencyAnalysis spectrum = 7; // Frequency spectrum
    AudioEnvelope envelope = 8;     // Amplitude envelope
    map<string, float> custom_features = 9; // Custom feature extraction
}

// ===========================
// FORMAT CONVERSION
// ===========================

/**
 * External audio format conversion
 */
message AudioFormatConversion {
    string conversion_id = 1;       // Unique conversion identifier
    string source_format = 2;       // Source format (WAV, MP3, FLAC, etc.)
    bytes source_data = 3;          // Source audio data
    SenaryAudioFormat target_format = 4; // Target Seigr format
    uint32 target_sample_rate = 5;  // Target sample rate
    uint32 target_channels = 6;     // Target channel count
    map<string, string> options = 7; // Conversion options
    bool preserve_quality = 8;      // Preserve quality during conversion
}

/**
 * Audio conversion result
 */
message AudioConversionResult {
    string conversion_id = 1;       // Conversion identifier
    bool success = 2;               // Conversion success
    SeigrAudioTrack converted_audio = 3; // Converted audio (if successful)
    string error_message = 4;       // Error message (if failed)
    float quality_score = 5;        // Quality preservation score
    float compression_ratio = 6;    // Compression ratio achieved
    float energy_saved = 7;         // Energy saved through senary optimization
}

// ===========================
// AUDIO SYNTHESIS
// ===========================

/**
 * Senary-optimized audio synthesis
 */
message SenaryAudioSynth {
    string synth_id = 1;            // Unique synthesizer identifier
    string waveform_type = 2;       // Waveform type (sine, square, sawtooth, etc.)
    float frequency = 3;            // Base frequency
    float amplitude = 4;            // Amplitude (0.0-5.0 in senary)
    float phase = 5;                // Phase offset
    repeated float harmonics = 6;   // Harmonic content
    AudioEnvelope envelope = 7;     // Amplitude envelope
    map<string, float> modulation = 8; // Modulation parameters
    bool energy_optimized = 9;      // Energy-optimized synthesis
}

/**
 * Audio synthesis request
 */
message SynthesisRequest {
    string request_id = 1;          // Unique request identifier
    SenaryAudioSynth synth_config = 2; // Synthesis configuration
    float duration = 3;             // Synthesis duration
    SenaryAudioFormat output_format = 4; // Output format
    uint32 sample_rate = 5;         // Output sample rate
    map<string, string> options = 6; // Synthesis options
}

/**
 * Audio synthesis result
 */
message SynthesisResult {
    string request_id = 1;          // Request identifier
    bool success = 2;               // Synthesis success
    AudioBuffer synthesized_audio = 3; // Synthesized audio buffer
    string error_message = 4;       // Error message (if failed)
    float generation_time = 5;      // Time taken to generate
    float energy_used = 6;          // Energy consumed
}

// ===========================
// AUDIO PROTOCOLS
// ===========================

/**
 * Audio system initialization
 */
message AudioInitRequest {
    string system_id = 1;           // System identifier
    repeated string preferred_devices = 2; // Preferred audio devices
    SenaryAudioFormat default_format = 3; // Default audio format
    uint32 default_sample_rate = 4; // Default sample rate
    uint32 default_buffer_size = 5; // Default buffer size
    bool energy_mode = 6;           // Energy-conscious mode
    map<string, string> configuration = 7; // System configuration
}

/**
 * Audio system status
 */
message AudioSystemStatus {
    string system_id = 1;           // System identifier
    repeated AudioDeviceCapabilities devices = 2; // Available devices
    repeated AudioStreamStatus active_streams = 3; // Active streams
    float cpu_usage = 4;            // Audio CPU usage
    float memory_usage = 5;         // Audio memory usage
    float energy_consumption = 6;   // Energy consumption
    uint32 active_processors = 7;   // Number of active processors
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 8;
}

/**
 * Audio operation request
 */
message AudioRequest {
    string request_id = 1;          // Unique request identifier
    string operation = 2;           // Operation type
    map<string, string> parameters = 3; // Operation parameters
    bytes payload = 4;              // Operation payload
    uint32 priority = 5;            // Request priority (0-5 in senary)
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 6;
}

/**
 * Audio operation response
 */
message AudioResponse {
    string request_id = 1;          // Request identifier
    bool success = 2;               // Operation success
    bytes result_data = 3;          // Result data
    string error_message = 4;       // Error message (if failed)
    float execution_time = 5;       // Execution time in seconds
    float energy_used = 6;          // Energy consumed
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 7;
}
