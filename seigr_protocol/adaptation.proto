syntax = "proto3";

package seigr.adaptation;

// Environmental Adaptation Protocol for Seigr OS
// Biomimetic adaptation inspired by evolutionary biology and cellular adaptation

import "seigr_timestamp.proto";
import "common.proto";

// Types of environmental factors that require adaptation
enum EnvironmentalFactor {
    FACTOR_UNKNOWN = 0;
    
    // Physical environment
    TEMPERATURE = 1;                   // Temperature changes
    HUMIDITY = 2;                      // Moisture levels
    PRESSURE = 3;                      // Atmospheric/system pressure
    VIBRATION = 4;                     // Physical vibrations
    ELECTROMAGNETIC_FIELD = 5;         // EM field variations
    RADIATION = 6;                     // Radiation levels
    
    // Resource environment
    ENERGY_AVAILABILITY = 10;          // Power/energy levels
    MEMORY_AVAILABILITY = 11;          // Memory resources
    CPU_AVAILABILITY = 12;             // Processing resources
    NETWORK_BANDWIDTH = 13;            // Network capacity
    STORAGE_CAPACITY = 14;             // Storage availability
    
    // System environment
    SYSTEM_LOAD = 20;                  // Overall system load
    USER_ACTIVITY = 21;                // User interaction patterns
    APPLICATION_DEMAND = 22;           // Application resource demands
    SECURITY_THREAT_LEVEL = 23;        // Threat environment
    NETWORK_LATENCY = 24;              // Communication delays
    ERROR_RATE = 25;                   // System error frequency
    
    // Social environment
    PEER_BEHAVIOR = 30;                // Behavior of peer systems
    COLLECTIVE_INTELLIGENCE = 31;      // Group intelligence level
    COLLABORATION_LEVEL = 32;          // Cooperation vs competition
    COMMUNICATION_PATTERNS = 33;       // How entities communicate
    
    // Temporal environment
    TIME_OF_DAY = 40;                  // Circadian patterns
    SEASONAL_PATTERNS = 41;            // Long-term cycles
    USAGE_PATTERNS = 42;               // Periodic usage variations
    WORKLOAD_PATTERNS = 43;            // Work cycle patterns
    
    // Advanced environment
    QUANTUM_FIELD_STATE = 50;          // Quantum environment
    CONSCIOUSNESS_FIELD = 51;          // Collective consciousness level
    INFORMATION_DENSITY = 52;          // Information environment richness
    COMPLEXITY_LEVEL = 53;             // Environmental complexity
}

// Adaptation strategies inspired by biological evolution
enum AdaptationStrategy {
    STRATEGY_UNKNOWN = 0;
    
    // Immediate adaptation (like reflexes)
    IMMEDIATE_RESPONSE = 1;            // Instant reaction
    HOMEOSTATIC_ADJUSTMENT = 2;        // Maintain equilibrium
    STRESS_RESPONSE = 3;               // Emergency adaptation
    AVOIDANCE = 4;                     // Avoid harmful conditions
    
    // Short-term adaptation (like acclimatization)
    BEHAVIORAL_MODIFICATION = 10;      // Change behavior patterns
    RESOURCE_REALLOCATION = 11;        // Redistribute resources
    PERFORMANCE_TUNING = 12;           // Adjust performance parameters
    COMMUNICATION_ADAPTATION = 13;     // Modify communication patterns
    
    // Long-term adaptation (like evolution)
    STRUCTURAL_EVOLUTION = 20;         // Change system structure
    ALGORITHM_EVOLUTION = 21;          // Evolve algorithms
    CAPABILITY_DEVELOPMENT = 22;       // Develop new capabilities
    SYMBIOTIC_RELATIONSHIP = 23;       // Form beneficial partnerships
    
    // Collective adaptation
    SWARM_ADAPTATION = 30;             // Collective behavior change
    CULTURAL_EVOLUTION = 31;           // Shared knowledge evolution
    CONSENSUS_ADAPTATION = 32;         // Group decision adaptation
    DISTRIBUTED_LEARNING = 33;         // Shared learning adaptation
    
    // Advanced adaptation
    QUANTUM_ADAPTATION = 40;           // Quantum state adaptation
    CONSCIOUSNESS_EVOLUTION = 41;      // Consciousness-level adaptation
    DIMENSIONAL_SHIFT = 42;            // Higher-dimensional adaptation
    TRANSCENDENT_ADAPTATION = 43;      // Beyond current limits
}

// Adaptation mechanisms inspired by biological processes
enum AdaptationMechanism {
    MECHANISM_UNKNOWN = 0;
    
    // Genetic-inspired mechanisms
    MUTATION = 1;                      // Random variation
    CROSSOVER = 2;                     // Combining successful traits
    SELECTION = 3;                     // Selecting best variants
    REPRODUCTION = 4;                  // Creating copies with variation
    
    // Learning mechanisms
    REINFORCEMENT_LEARNING = 10;       // Reward-based learning
    IMITATION_LEARNING = 11;           // Learning by copying
    TRIAL_AND_ERROR = 12;              // Experimental learning
    PATTERN_RECOGNITION = 13;          // Learning patterns
    
    // Neural mechanisms
    SYNAPTIC_PLASTICITY = 20;          // Connection strength changes
    NEURAL_PRUNING = 21;               // Removing unused connections
    NEURAL_GROWTH = 22;                // Growing new connections
    MEMORY_CONSOLIDATION = 23;         // Strengthening important memories
    
    // Cellular mechanisms
    GENE_EXPRESSION = 30;              // Activating/deactivating features
    PROTEIN_SYNTHESIS = 31;            // Creating new functional components
    METABOLIC_ADJUSTMENT = 32;         // Changing energy usage
    CELLULAR_DIFFERENTIATION = 33;     // Specializing function
    
    // System mechanisms
    CONFIGURATION_CHANGE = 40;         // Modifying system settings
    ALGORITHM_MODIFICATION = 41;       // Changing algorithms
    ARCHITECTURE_EVOLUTION = 42;       // Changing system structure
    PROTOCOL_ADAPTATION = 43;          // Modifying communication protocols
    
    // Emergent mechanisms
    SELF_ORGANIZATION = 50;            // Spontaneous organization
    EMERGENCE = 51;                    // New properties emerging
    PHASE_TRANSITION = 52;             // Sudden state change
    COMPLEX_ADAPTATION = 53;           // Multi-level adaptation
}

// Environmental sensor data
message EnvironmentalSensor {
    string sensor_id = 1;
    string sensor_name = 2;
    EnvironmentalFactor factor_measured = 3;
    
    // Current measurement
    float current_value = 4;
    string measurement_unit = 5;
    float measurement_accuracy = 6;    // Confidence in measurement (0-1)
    
    // Historical data
    float baseline_value = 7;          // Normal/expected value
    float minimum_observed = 8;
    float maximum_observed = 9;
    float average_value = 10;
    repeated float recent_values = 11; // Recent measurement history
    
    // Trend analysis
    float trend_direction = 12;        // -1 (decreasing) to 1 (increasing)
    float rate_of_change = 13;         // Speed of change
    float volatility = 14;             // How much values fluctuate
    bool stable = 15;                  // Is the environment stable?
    
    // Thresholds and alerts
    float optimal_range_min = 16;
    float optimal_range_max = 17;
    float warning_threshold_low = 18;
    float warning_threshold_high = 19;
    float critical_threshold_low = 20;
    float critical_threshold_high = 21;
    
    // Sensor characteristics
    uint32 sampling_rate_ms = 22;      // How often sensor reads
    float sensor_sensitivity = 23;     // Smallest detectable change
    bool real_time_monitoring = 24;
    uint32 response_time_ms = 25;      // Time to detect changes
    
    // Adaptation triggers
    bool triggers_adaptation = 26;     // Does this sensor trigger adaptation?
    float adaptation_threshold = 27;   // Change level that triggers adaptation
    repeated string adaptation_actions = 28; // What adaptations it can trigger
    
    // Predictive capabilities
    bool predictive_available = 29;    // Can predict future values?
    repeated float predicted_values = 30; // Future predictions
    uint32 prediction_horizon_ms = 31; // How far ahead can predict
    float prediction_accuracy = 32;    // Accuracy of predictions
    
    // Energy and performance
    float energy_consumption_mw = 33;
    bool senary_optimized = 34;
    
    // Metadata
    seigr.protocol.timestamp.SeigrTimestamp last_measurement = 35;
    seigr.protocol.timestamp.SeigrTimestamp calibration_time = 36;
    map<string, string> metadata = 37;
}

// Adaptation capability of a system component
message AdaptationCapability {
    string capability_id = 1;
    string capability_name = 2;
    string component_id = 3;           // What component has this capability
    
    // Adaptation characteristics
    repeated EnvironmentalFactor responsive_factors = 4;
    repeated AdaptationStrategy supported_strategies = 5;
    repeated AdaptationMechanism available_mechanisms = 6;
    
    // Performance characteristics
    uint32 adaptation_speed_ms = 7;    // How quickly can adapt
    float adaptation_effectiveness = 8; // How well adaptation works (0-1)
    float energy_cost_per_adaptation = 9;
    float resource_overhead = 10;      // Resource cost of adaptation
    
    // Learning characteristics
    bool learning_enabled = 11;        // Can improve over time?
    float learning_rate = 12;          // How quickly it learns
    uint32 memory_capacity = 13;       // How much it can remember
    repeated string learned_patterns = 14; // Patterns it has learned
    
    // Adaptation scope
    float adaptation_range_min = 15;   // Minimum environmental change it can handle
    float adaptation_range_max = 16;   // Maximum environmental change it can handle
    bool reversible = 17;              // Can undo adaptations?
    bool cumulative = 18;              // Do adaptations build up?
    
    // Constraints and limitations
    uint32 max_adaptations_per_hour = 19;
    float energy_budget_per_hour = 20;
    repeated string adaptation_conflicts = 21; // Conflicting adaptations
    repeated string dependencies = 22;  // What this adaptation depends on
    
    // Success metrics
    uint64 successful_adaptations = 23;
    uint64 failed_adaptations = 24;
    float success_rate = 25;
    float average_improvement = 26;    // Average improvement from adaptation
    
    // Evolution and improvement
    bool evolving = 27;                // Is capability evolving?
    uint32 evolution_cycles = 28;
    repeated string evolutionary_improvements = 29;
    
    // Collaboration with other adaptations
    repeated string synergistic_capabilities = 30; // Works well with these
    repeated string competing_capabilities = 31;   // Competes with these
    bool coordination_required = 32;   // Needs coordination with others?
    
    // Optimization characteristics
    bool senary_optimized = 33;
    float senary_efficiency_factor = 34;
    
    // Metadata
    seigr.protocol.timestamp.SeigrTimestamp last_used = 35;
    seigr.protocol.timestamp.SeigrTimestamp created = 36;
    map<string, string> metadata = 37;
}

// Adaptation event representing a specific adaptation instance
message AdaptationEvent {
    string event_id = 1;
    string component_id = 2;
    string capability_id = 3;
    
    // Trigger information
    EnvironmentalFactor triggering_factor = 4;
    float trigger_value = 5;           // Environmental value that triggered adaptation
    float trigger_threshold = 6;       // Threshold that was crossed
    string trigger_reason = 7;         // Why adaptation was triggered
    
    // Adaptation details
    AdaptationStrategy strategy_used = 8;
    AdaptationMechanism mechanism_used = 9;
    repeated string adaptations_applied = 10;
    map<string, float> parameter_changes = 11;
    
    // Before and after state
    map<string, float> state_before = 12;
    map<string, float> state_after = 13;
    float performance_before = 14;
    float performance_after = 15;
    
    // Execution characteristics
    seigr.protocol.timestamp.SeigrTimestamp started_at = 16;
    seigr.protocol.timestamp.SeigrTimestamp completed_at = 17;
    uint32 duration_ms = 18;
    bool successful = 19;
    string error_message = 20;         // If unsuccessful
    
    // Resource consumption
    float energy_consumed = 21;
    map<string, float> resources_used = 22;
    
    // Effectiveness measurement
    float effectiveness_score = 23;    // How well adaptation worked (0-1)
    float improvement_achieved = 24;   // Actual improvement gained
    bool goals_achieved = 25;
    repeated string side_effects = 26; // Unintended consequences
    
    // Learning and memory
    string lesson_learned = 27;
    bool should_remember = 28;         // Should this be remembered for future?
    float confidence_level = 29;       // Confidence in this adaptation approach
    
    // Collaboration and coordination
    repeated string coordinated_adaptations = 30; // Other adaptations done simultaneously
    bool coordination_successful = 31;
    repeated string affected_components = 32;
    
    // Reversibility
    bool reversible = 33;
    string reversal_procedure = 34;
    bool auto_reversal_enabled = 35;
    uint32 reversal_timeout_ms = 36;
    
    // Optimization results
    bool senary_optimized = 37;
    float senary_efficiency_gain = 38;
    
    // Metadata
    map<string, string> metadata = 39;
}

// Adaptation policy defining when and how to adapt
message AdaptationPolicy {
    string policy_id = 1;
    string policy_name = 2;
    string policy_description = 3;
    
    // Policy scope
    repeated string applicable_components = 4;
    repeated EnvironmentalFactor monitored_factors = 5;
    repeated string applicable_scenarios = 6;
    
    // Trigger conditions
    map<string, float> trigger_thresholds = 7;
    string trigger_logic = 8;          // "any", "all", "custom"
    bool proactive_adaptation = 9;     // Adapt before problems occur
    bool reactive_adaptation = 10;     // Adapt after problems detected
    
    // Adaptation preferences
    repeated AdaptationStrategy preferred_strategies = 11;
    repeated AdaptationMechanism preferred_mechanisms = 12;
    float aggressiveness_level = 13;   // How aggressively to adapt (0-1)
    bool conservative_mode = 14;       // Prefer safe, tested adaptations
    
    // Resource constraints
    float max_energy_per_adaptation = 15;
    float max_energy_per_hour = 16;
    uint32 max_adaptations_per_hour = 17;
    map<string, float> resource_budgets = 18;
    
    // Quality and safety constraints
    float minimum_success_probability = 19; // Don't adapt unless likely to succeed
    bool require_reversibility = 20;   // Only reversible adaptations
    uint32 maximum_recovery_time_ms = 21; // Maximum time to recover if adaptation fails
    repeated string forbidden_adaptations = 22;
    
    // Learning and evolution settings
    bool learning_enabled = 23;
    bool policy_evolution_enabled = 24;
    float learning_rate = 25;
    uint32 experience_memory_size = 26;
    
    // Coordination settings
    bool coordination_required = 27;   // Must coordinate with other policies
    repeated string coordination_policies = 28;
    string conflict_resolution = 29;   // How to resolve policy conflicts
    
    // Timing constraints
    uint32 minimum_interval_between_adaptations_ms = 30;
    uint32 adaptation_timeout_ms = 31;
    bool time_of_day_restrictions = 32;
    repeated string allowed_time_windows = 33;
    
    // Performance targets
    map<string, float> performance_targets = 34;
    float minimum_improvement_threshold = 35; // Minimum improvement to be worthwhile
    bool optimize_for_senary = 36;
    
    // Monitoring and feedback
    bool monitoring_enabled = 37;
    uint32 monitoring_interval_ms = 38;
    bool feedback_collection_enabled = 39;
    
    // Security and authorization
    repeated string authorized_triggers = 40;
    seigr.common.ThreatLevel required_security_level = 41;
    bool require_human_approval = 42;
    
    // Metadata
    seigr.protocol.timestamp.SeigrTimestamp created = 43;
    seigr.protocol.timestamp.SeigrTimestamp last_updated = 44;
    string policy_version = 45;
    map<string, string> metadata = 46;
}

// System adaptation status
message AdaptationSystemStatus {
    string system_id = 1;
    
    // Overall adaptation health
    float adaptation_health_score = 2; // Overall system adaptation health (0-1)
    uint32 active_sensors = 3;
    uint32 active_capabilities = 4;
    uint32 active_policies = 5;
    
    // Current environmental state
    repeated EnvironmentalSensor environmental_state = 6;
    map<string, float> environmental_summary = 7;
    bool environment_stable = 8;
    repeated string environmental_alerts = 9;
    
    // Recent adaptation activity
    uint32 adaptations_last_hour = 10;
    uint32 successful_adaptations = 11;
    uint32 failed_adaptations = 12;
    float adaptation_success_rate = 13;
    
    // Performance metrics
    float overall_system_performance = 14;
    float adaptation_effectiveness = 15;
    float resource_efficiency = 16;
    float energy_efficiency = 17;
    
    // Learning and evolution status
    bool learning_active = 18;
    uint32 patterns_learned = 19;
    uint32 policies_evolved = 20;
    float collective_intelligence_level = 21;
    
    // Predictive capabilities
    bool predictive_adaptation_available = 22;
    repeated string predicted_adaptations = 23;
    float prediction_confidence = 24;
    
    // Resource utilization
    float adaptation_energy_consumption = 25;
    map<string, float> resource_utilization = 26;
    bool resource_constraints_active = 27;
    
    // Optimization status
    bool senary_optimization_active = 28;
    float senary_efficiency_level = 29;
    
    // Alerts and recommendations
    repeated string active_alerts = 30;
    repeated string optimization_recommendations = 31;
    repeated string potential_improvements = 32;
    
    // Metadata
    seigr.protocol.timestamp.SeigrTimestamp status_time = 33;
    map<string, string> metadata = 34;
}

// Adaptation request
message AdaptationRequest {
    string session_id = 1;
    string requesting_component = 2;
    
    // Request type
    enum AdaptationOperation {
        OPERATION_UNKNOWN = 0;
        REGISTER_SENSOR = 1;           // Register environmental sensor
        REGISTER_CAPABILITY = 2;       // Register adaptation capability
        TRIGGER_ADAPTATION = 3;        // Manually trigger adaptation
        UPDATE_POLICY = 4;             // Update adaptation policy
        MONITOR_ENVIRONMENT = 5;       // Start environmental monitoring
        PREDICT_ADAPTATION = 6;        // Predict future adaptations needed
        OPTIMIZE_ADAPTATION = 7;       // Optimize adaptation system
        LEARN_PATTERN = 8;             // Learn new adaptation pattern
        EVOLVE_POLICY = 9;             // Evolve adaptation policy
        COORDINATE_ADAPTATION = 10;    // Coordinate multiple adaptations
        EMERGENCY_ADAPTATION = 11;     // Emergency adaptation
        RESET_ADAPTATION = 12;         // Reset to baseline state
    }
    AdaptationOperation operation = 3;
    
    // Request data
    EnvironmentalSensor sensor_data = 4;
    AdaptationCapability capability_data = 5;
    AdaptationPolicy policy_data = 6;
    AdaptationEvent trigger_event = 7;
    
    // Environmental context
    map<string, float> current_environment = 8;
    repeated string environmental_alerts = 9;
    float urgency_level = 10;          // How urgent is adaptation (0-1)
    
    // Adaptation preferences
    repeated AdaptationStrategy preferred_strategies = 11;
    bool allow_aggressive_adaptation = 12;
    bool require_reversibility = 13;
    float max_resource_usage = 14;
    
    // Performance requirements
    uint32 max_adaptation_time_ms = 15;
    float min_effectiveness_required = 16;
    bool senary_optimization_preferred = 17;
    
    // Coordination requirements
    repeated string coordinate_with_components = 18;
    bool require_coordination = 19;
    string coordination_strategy = 20;
    
    // Security and authorization
    string authorization_token = 21;
    seigr.common.ThreatLevel security_level = 22;
    bool authenticated = 23;
}

// Response to adaptation requests
message AdaptationResponse {
    string session_id = 1;
    bool success = 2;
    string error_message = 3;
    
    // Adaptation results
    repeated AdaptationEvent adaptations_performed = 4;
    AdaptationSystemStatus system_status = 5;
    float effectiveness_achieved = 6;
    float improvement_gained = 7;
    
    // Resource consumption
    uint32 adaptation_time_ms = 8;
    float energy_consumed = 9;
    map<string, float> resources_used = 10;
    bool senary_optimized = 11;
    
    // Environmental impact
    map<string, float> environmental_changes = 12;
    bool environment_stabilized = 13;
    repeated string environmental_improvements = 14;
    
    // Learning outcomes
    repeated string patterns_learned = 15;
    repeated string insights_gained = 16;
    bool policy_evolution_triggered = 17;
    
    // Future predictions
    repeated string predicted_future_adaptations = 18;
    float prediction_confidence = 19;
    repeated string optimization_opportunities = 20;
    
    // Coordination results
    repeated string coordinated_components = 21;
    bool coordination_successful = 22;
    float coordination_effectiveness = 23;
    
    // Recommendations
    repeated string adaptation_recommendations = 24;
    repeated string policy_recommendations = 25;
    string optimization_suggestions = 26;
    
    // System health impact
    float system_health_improvement = 27;
    repeated string system_benefits = 28;
    repeated string potential_risks = 29;
    
    // Metadata
    seigr.protocol.timestamp.SeigrTimestamp timestamp = 30;
    map<string, string> metadata = 31;
}

// Service definitions for environmental adaptation
service AdaptationService {
    // Sensor and monitoring
    rpc RegisterEnvironmentalSensor(AdaptationRequest) returns (AdaptationResponse);
    rpc MonitorEnvironment(AdaptationRequest) returns (stream AdaptationResponse);
    rpc GetEnvironmentalStatus(AdaptationRequest) returns (AdaptationResponse);
    
    // Capability management
    rpc RegisterAdaptationCapability(AdaptationRequest) returns (AdaptationResponse);
    rpc UpdateAdaptationCapability(AdaptationRequest) returns (AdaptationResponse);
    rpc GetAdaptationCapabilities(AdaptationRequest) returns (AdaptationResponse);
    
    // Adaptation execution
    rpc TriggerAdaptation(AdaptationRequest) returns (AdaptationResponse);
    rpc CoordinateAdaptations(AdaptationRequest) returns (AdaptationResponse);
    rpc EmergencyAdaptation(AdaptationRequest) returns (AdaptationResponse);
    
    // Policy management
    rpc UpdateAdaptationPolicy(AdaptationRequest) returns (AdaptationResponse);
    rpc EvolveAdaptationPolicy(AdaptationRequest) returns (AdaptationResponse);
    rpc GetAdaptationPolicies(AdaptationRequest) returns (AdaptationResponse);
    
    // Learning and prediction
    rpc LearnAdaptationPattern(AdaptationRequest) returns (AdaptationResponse);
    rpc PredictFutureAdaptations(AdaptationRequest) returns (AdaptationResponse);
    rpc AnalyzeAdaptationEffectiveness(AdaptationRequest) returns (AdaptationResponse);
    
    // Optimization
    rpc OptimizeAdaptationSystem(AdaptationRequest) returns (AdaptationResponse);
    rpc OptimizeForSenary(AdaptationRequest) returns (AdaptationResponse);
    rpc CalculateAdaptationEfficiency(AdaptationRequest) returns (AdaptationResponse);
    
    // System management
    rpc GetSystemAdaptationStatus(AdaptationRequest) returns (AdaptationResponse);
    rpc ResetAdaptationSystem(AdaptationRequest) returns (AdaptationResponse);
}
